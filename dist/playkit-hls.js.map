{"version":3,"sources":["./hls/webpack/universalModuleDefinition","./hls/webpack/bootstrap","./hls/external {\"commonjs\":\"@playkit-js/playkit-js\",\"commonjs2\":\"@playkit-js/playkit-js\",\"amd\":\"playkit-js\",\"root\":[\"playkit\",\"core\"]}","./hls/external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}","./hls/./errors.js","./hls/./loader.js","./hls/./jsonp-ploader.js","./hls/./hls-adapter.js","./hls/./index.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","__WEBPACK_EXTERNAL_MODULE__1__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","HlsJsErrorMap","Hlsjs","ErrorDetails","MANIFEST_LOAD_ERROR","category","Error","Category","MANIFEST","code","Code","HTTP_ERROR","MANIFEST_LOAD_TIMEOUT","TIMEOUT","MANIFEST_PARSING_ERROR","HLSJS_CANNOT_PARSE","LEVEL_LOAD_ERROR","NETWORK","LEVEL_LOAD_TIMEOUT","LEVEL_SWITCH_ERROR","PLAYER","BITRATE_SWITCH_ISSUE","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","FRAG_PARSING_ERROR","MEDIA","HLS_FRAG_PARSING_ERROR","BUFFER_APPEND_ERROR","HLS_BUFFER_APPEND_ISSUE","BUFFER_APPENDING_ERROR","HLS_BUFFER_APPENDING_ISSUE","BUFFER_STALLED_ERROR","HLS_BUFFER_STALLED_ERROR","loader","config","readystatechange","loadInternal","xhr","context","this","XMLHttpRequest","stats","tfirst","loaded","xhrSetupPromise","xhrSetup","url","e","open","readyState","Promise","reject","resolve","then","rangeEnd","setRequestHeader","rangeStart","onreadystatechange","onprogress","loadprogress","responseType","requestTimeout","setTimeout","loadtimeout","timeout","send","catch","callbacks","onError","status","text","message","DefaultConfig","pLoader","loadOrig","load","callback","redirectExternalStreamsHandler","type","Utils","Http","jsonp","redirectExternalStreamsTimeout","uri","data","HlsAdapter","videoElement","source","_logger","debug","version","Events","ERROR","_onError","MANIFEST_LOADED","_onManifestLoaded","LEVEL_SWITCHED","_onLevelSwitched","AUDIO_TRACK_SWITCHED","_onAudioTrackSwitched","FPS_DROP","_onFpsDrop","FRAG_PARSING_METADATA","_onFragParsingMetadata","FRAG_LOADED","_onFragLoaded","MEDIA_ATTACHED","_onMediaAttached","LEVEL_LOADED","_onLevelLoaded","isLive","endSN","details","_lastLoadedFragSN","_sameFragSNLoadedCount","_config","network","maxStaleLevelReloads","error","PKError","Severity","CRITICAL","LIVE_MANIFEST_REFRESH_ERROR","fragSN","_trigger","EventType","destroy","mergeDeep","_init","createAdapter","adapterConfig","copyDeep","hasPropertyPath","options","sources","forceRedirectExternalStreams","getPropertyPath","hlsConfig","startPosition","startTime","subtitleDisplay","fpsDroppedFramesInterval","abr","fpsDroppedMonitoringThreshold","capLevelOnFPSDrop","enableCEA708Captions","captionsTextTrack1Label","captionsTextTrack1LanguageCode","captionsTextTrack2Label","captionsTextTrack2LanguageCode","enabled","capLevelToPlayerSize","defaultBandwidthEstimate","abrEwmaDefaultEstimate","restrictions","createPropertyPath","lowLatencyMode","playback","html5","hls","canPlayType","mimeType","canHlsPlayType","_hlsMimeTypes","includes","toLowerCase","isMSESupported","toString","canPlayDrm","warn","isSupported","isHlsSupported","_maybeSetFilters","_hls","_capabilities","fpsControl","_addBindings","requestFilterPromise","pkRequest","body","headers","requestFilter","RequestType","frag","SEGMENT","updatedRequest","entries","forEach","entry","withCredentials","_requestFilterError","self","event","currentTarget","aborted","clearTimeout","loading","first","Math","max","performance","now","start","len","end","response","byteLength","responseText","length","total","responseFilterPromise","pkResponse","responseURL","originalUrl","convertHeadersToDictionary","getAllResponseHeaders","responseFilter","updatedResponse","onSuccess","_responseFilterError","retry","maxRetry","statusText","retryDelay","retryTimeout","min","maxRetryDelay","_mediaAttachedPromise","_adapterEventsBindings","on","_onRecoveredCallback","_onRecovered","_onAddTrack","_eventManager","listen","_videoElement","textTracks","onaddtrack","id3Track","Array","from","find","track","label","id3Cues","cues","newCues","samples","sample","cue","binarySearch","pts","timedMetadata","createTimedMetadata","push","TIMED_METADATA_ADDED","subtitleTracks","CEATextTrack","_parseCEATextTrack","_playerTracks","TRACKS_CHANGED","tracks","attachMediaSource","src","Dom","setAttribute","removeAttribute","detachMediaSource","floor","duration","currentTime","_reset","_loadPromiseHandlers","HLS_FATAL_MEDIA_ERROR","_loadPromise","handleMediaError","MEDIA_ERR_DECODE","_handleMediaError","_startTime","_loadInternal","_sourceObj","loadSource","attachMedia","ABR_MODE_CHANGED","isAdaptiveBitrateEnabled","_reloadWithDirectManifest","_triedReloadWithRedirect","_nativeTextTracksMap","_removeBindings","detachMedia","_parseTracks","audioTracks","_parseAudioTracks","videoTracks","_parseVideoTracks","levels","_parseTextTracks","concat","hlsAudioTracks","settings","id","active","audioTrack","language","lang","index","AudioTrack","hlsVideoTracks","startLevel","bandwidth","bitrate","width","height","VideoTrack","hlsTextTracks","hlsTextTrack","default","kind","TextTrack","textTrack","selectAudioTrack","selectVideoTrack","videoTrack","currentLevel","selectTextTrack","subtitleTrack","_notifyTrackChanged","_selectNativeTextTrack","selectedTrack","disableNativeTextTracks","_onTrackChanged","hideTextTrack","enableAdaptiveBitrate","nextLevel","autoLevelEnabled","applyABRRestriction","_maybeApplyAbrRestrictions","_getLevelDetails","level","nextAutoLevel","nextLoadLevel","_getLiveEdge","liveEdge","liveSyncPosition","liveSyncDuration","liveSyncDurationCount","targetduration","seekToLiveEdge","getSegmentDuration","fragCurrent","live","autoStartLoad","startLoad","manifestDownloadTime","miliSeconds","filter","availableTracks","filterTracksByRestriction","minLevel","maxLevel","pop","minAutoBitrate","autoLevelCapping","activeTrackInRange","some","_handleWaitingUponAudioTrackSwitch","Env","browser","listenOnce","TIME_UPDATE","PLAYING","_getErrorDataObject","errorDataObject","AUDIO_TRACK_LOAD_ERROR","responseCode","AUDIO_TRACK_LOAD_TIMEOUT","reason","fragUrl","FRAG_DECRYPT_ERROR","KEY_LOAD_ERROR","fragDecryptedDataUri","decryptdata","KEY_LOAD_TIMEOUT","BUFFER_ADD_CODEC_ERROR","errorMsg","err","buffer","errorType","errorName","errorFatal","fatal","ErrorTypes","NETWORK_ERROR","REQUEST_FILTER_ERROR","RESPONSE_FILTER_ERROR","RECOVERABLE","MEDIA_ERROR","severity","recover","_checkTimeDeltaHasPassed","_recoverDecodingErrorDate","recoverDecodingErrorDelay","LOADED_METADATA","_recoverDecodingError","_recoverSwapAudioCodecDate","recoverSwapAudioCodecDelay","_recoverSwapAudioCodec","MEDIA_RECOVERED","removeEventListener","delay","recoverMediaError","swapAudioCodec","off","removeAll","getStartTimeOfDvrWindow","fragments","fragLength","maxLatency","undefined","liveMaxLatencyDuration","liveMaxLatencyDurationCount","maxFragLookUpTolerance","fragmentDownloadTime","bytes","_getLiveTargetBuffer","targetBufferVal","NaN","maxMaxBufferLength","BaseMediaSourceAdapter","getLogger","VERSION","__VERSION__","NAME","__NAME__","registerMediaSourceAdapter"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,0BAA2BA,QAAQ,WAC3C,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,MAAO,CAAC,aAAc,UAAWJ,GACd,iBAAZC,QACdA,QAAa,IAAID,EAAQG,QAAQ,0BAA2BA,QAAQ,YAEpEJ,EAAc,QAAIA,EAAc,SAAK,GAAIA,EAAc,QAAO,IAAIC,EAAQD,EAAc,QAAQ,KAAGA,EAAU,MAR/G,CASGO,QAAQ,SAASC,EAAgCC,GACpD,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUV,QAGnC,IAAIC,EAASO,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHZ,QAAS,IAUV,OANAa,EAAQH,GAAUI,KAAKb,EAAOD,QAASC,EAAQA,EAAOD,QAASS,GAG/DR,EAAOW,GAAI,EAGJX,EAAOD,QA0Df,OArDAS,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASjB,EAASkB,EAAMC,GAC3CV,EAAoBW,EAAEpB,EAASkB,IAClCG,OAAOC,eAAetB,EAASkB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASzB,GACX,oBAAX0B,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAetB,EAAS0B,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAetB,EAAS,aAAc,CAAE4B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASnC,GAChC,IAAIkB,EAASlB,GAAUA,EAAO8B,WAC7B,WAAwB,OAAO9B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAQ,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrDzC,EAAOD,QAAUM,G,cCAjBL,EAAOD,QAAUO,G,mXCOXoC,IAAgC,MACnCC,IAAMC,aAAaC,qBAAsB,CACxCC,SAAUC,QAAMC,SAASC,SACzBC,KAAMH,QAAMI,KAAKC,YAHiB,EAKnCT,IAAMC,aAAaS,uBAAwB,CAC1CP,SAAUC,QAAMC,SAASC,SACzBC,KAAMH,QAAMI,KAAKG,SAPiB,EASnCX,IAAMC,aAAaW,wBAAyB,CAC3CT,SAAUC,QAAMC,SAASC,SACzBC,KAAMH,QAAMI,KAAKK,oBAXiB,EAanCb,IAAMC,aAAaa,kBAAmB,CACrCX,SAAUC,QAAMC,SAASU,QACzBR,KAAMH,QAAMI,KAAKC,YAfiB,EAiBnCT,IAAMC,aAAae,oBAAqB,CACvCb,SAAUC,QAAMC,SAASU,QACzBR,KAAMH,QAAMI,KAAKG,SAnBiB,EAqBnCX,IAAMC,aAAagB,oBAAqB,CACvCd,SAAUC,QAAMC,SAASa,OACzBX,KAAMH,QAAMI,KAAKW,sBAvBiB,EAyBnCnB,IAAMC,aAAamB,iBAAkB,CACpCjB,SAAUC,QAAMC,SAASU,QACzBR,KAAMH,QAAMI,KAAKC,YA3BiB,EA6BnCT,IAAMC,aAAaoB,yBAA0B,CAC5ClB,SAAUC,QAAMC,SAASU,QACzBR,KAAMH,QAAMI,KAAKC,YA/BiB,EAiCnCT,IAAMC,aAAaqB,mBAAoB,CACtCnB,SAAUC,QAAMC,SAASU,QACzBR,KAAMH,QAAMI,KAAKG,SAnCiB,EAqCnCX,IAAMC,aAAasB,oBAAqB,CACvCpB,SAAUC,QAAMC,SAASmB,MACzBjB,KAAMH,QAAMI,KAAKiB,wBAvCiB,EAyCnCzB,IAAMC,aAAayB,qBAAsB,CACxCvB,SAAUC,QAAMC,SAASmB,MACzBjB,KAAMH,QAAMI,KAAKmB,yBA3CiB,EA6CnC3B,IAAMC,aAAa2B,wBAAyB,CAC3CzB,SAAUC,QAAMC,SAASmB,MACzBjB,KAAMH,QAAMI,KAAKqB,4BA/CiB,EAiDnC7B,IAAMC,aAAa6B,sBAAuB,CACzC3B,SAAUC,QAAMC,SAASmB,MACzBjB,KAAMH,QAAMI,KAAKuB,0BAnDiB,G,ICAjBC,E,oBACnB,WAAYC,GAAgB,aAC1B,cAAMA,IAAN,KACIA,GAAUA,EAAOC,mBACnB,EAAKA,iBAAmBD,EAAOC,kBAHP,E,0GAO5BC,aAAA,WAAe,IACTC,EADS,OAEXC,EAAUC,KAAKD,QACjBD,EAAME,KAAKN,OAAS,IAAIO,eAExB,IAAIC,EAAQF,KAAKE,MACjBA,EAAMC,OAAS,EACfD,EAAME,OAAS,EACf,IAEIC,EAFEC,EAAWN,KAAKM,SAGtB,IACE,GAAIA,EACF,IACED,EAAkBC,EAASR,EAAKC,EAAQQ,IAAKR,GAC7C,MAAOS,GAGPV,EAAIW,KAAK,MAAOV,EAAQQ,KAAK,GAC7BF,EAAkBC,EAASR,EAAKC,EAAQQ,IAAKR,GAG5CD,EAAIY,YACPZ,EAAIW,KAAK,MAAOV,EAAQQ,KAAK,GAE/B,MAAOC,GAEPH,EAAkBM,QAAQC,OAAOJ,IAEnCH,EAAkBA,GAAmBM,QAAQE,WAE1CC,MAAK,WACAf,EAAQgB,UACVjB,EAAIkB,iBAAiB,QAAS,SAAWjB,EAAQkB,WAAa,KAAOlB,EAAQgB,SAAW,IAG1FjB,EAAIoB,mBAAqB,EAAKtB,iBAAiB3C,KAAK,GACpD6C,EAAIqB,WAAa,EAAKC,aAAanE,KAAK,GACxC6C,EAAIuB,aAAetB,EAAQsB,aAG3B,EAAKC,eAAiBnG,OAAOoG,WAAW,EAAKC,YAAYvE,KAAK,GAAO,EAAK0C,OAAO8B,SACjF3B,EAAI4B,UAELC,OAAM,SAAAnB,GACL,EAAKoB,UAAUC,QAAQ,CAAC5D,KAAM6B,EAAIgC,OAAQC,KAAMvB,EAAEwB,SAAUjC,EAASD,O,GArDzCpC,IAAMuE,cAAcvC,Q,UCEnCwC,E,oBAcnB,WAAYvC,GAAgB,MAEpBwC,GADN,cAAMxC,IAAN,MACsByC,KAAKnF,K,yHAAV,KACXoF,EAAWH,EAAQI,+BAHC,OAI1B,EAAKF,KAAO,SAACrC,EAASJ,EAAQiC,GAC5B,IAAMrB,EAAMR,EAAQQ,IACC,aAAjBR,EAAQwC,KACVC,QAAMC,KAAKC,MAAMnC,EAAK8B,EAAU,CAC9BZ,QAASS,EAAQS,iCAEhB7B,MAAK,SAAA8B,GACJ7C,EAAQQ,IAAMqC,EACdT,EAASpC,EAASJ,EAAQiC,MAE3BD,OAAM,kBAAMQ,EAASpC,EAASJ,EAAQiC,MAEzCO,EAASpC,EAASJ,EAAQiC,IAhBJ,E,iGAdOlC,G,6tCAQe,SAACmD,EAAMD,GAAP,OAAeA,I,wCAR9CV,G,0FCkBAY,E,oBAgPnB,WAAYC,EAAgCC,EAA6BrD,GAAgB,eACvFmD,EAAWG,QAAQC,MAAM,kCAAoCxF,IAAMyF,SADoB,IAEvF,cAAMJ,EAAcC,EAAQrD,IAA5B,MAFuF,YA5MxEjC,KA4MwE,mCAjLrD,GAiLqD,uBAzJ3D,IAyJ2D,oBAnJnE,GAmJmE,8BAxI1D,GAwI0D,+BAvIzD,GAuIyD,8BAtIlE,IAsIkE,4BArI5D,GAqI4D,gCApIxD,GAoIwD,wCA5HtFA,IAAM0F,OAAOC,OAAQ,SAAC7C,EAAGqC,GAAJ,OAAa,EAAKS,SAAST,IA4HsC,EA3HtFnF,IAAM0F,OAAOG,iBAAkB,SAAC/C,EAAGqC,GAAJ,OAAa,EAAKW,kBAAkBX,IA2HmB,EA1HtFnF,IAAM0F,OAAOK,gBAAiB,SAACjD,EAAGqC,GAAJ,OAAa,EAAKa,iBAAiBlD,EAAGqC,IA0HkB,EAzHtFnF,IAAM0F,OAAOO,sBAAuB,SAACnD,EAAGqC,GAAJ,OAAa,EAAKe,sBAAsBpD,EAAGqC,IAyHO,EAxHtFnF,IAAM0F,OAAOS,UAAW,SAACrD,EAAGqC,GAAJ,OAAa,EAAKiB,WAAWjB,IAwHiC,EAvHtFnF,IAAM0F,OAAOW,uBAAwB,SAACvD,EAAGqC,GAAJ,OAAa,EAAKmB,uBAAuBnB,IAuHQ,EAtHtFnF,IAAM0F,OAAOa,aAAc,SAACzD,EAAGqC,GAAJ,OAAa,EAAKqB,cAAcrB,IAsH2B,EArHtFnF,IAAM0F,OAAOe,gBAAiB,kBAAM,EAAKC,oBAqH6C,EApHtF1G,IAAM0F,OAAOiB,cAAe,SAAC7D,EAAGqC,GAAJ,OAAa,EAAKyB,eAAe9D,EAAGqC,IAoHsB,6BA4/BxE,SAACrC,EAAQqC,GACxB,GAAI,EAAK0B,SAAU,KAELC,EACR3B,EADF4B,QAAUD,MAEZ,GAAI,EAAKE,oBAAsBF,EAAO,CAGpC,GAFA,EAAKG,yBACL7B,EAAWG,QAAQC,MAAnB,2BAAoD,EAAKyB,uBAAzD,aAA4F,EAAKC,QAAQC,QAAQC,sBAC7G,EAAKH,wBAA0B,EAAKC,QAAQC,QAAQC,qBAAsB,CAC5EhC,EAAWG,QAAQ8B,MAAnB,uCACA,IAAMA,EAAQ,IAAIC,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASU,QAASuG,QAAQ9G,KAAKiH,4BAA6B,CACvHC,OAAQZ,IAGV,OADA,EAAKa,SAASC,YAAUjC,MAAO0B,GACxB,EAAKQ,UAEdzC,EAAWG,QAAQC,MAAnB,oBAA6CsB,QAE7C,EAAKG,uBAAyB,EAEhC,EAAKD,kBAAoBF,MA7gC3B,EAAKI,QAAUpC,QAAMrG,OAAOqJ,UAAU,GAAIvD,EAAe,EAAK2C,SAC9D,EAAKa,QAJkF,E,yFAxGlFC,cAAP,SAAqB3C,EAAgCC,EAA6BrD,GAChF,IAAIgG,EAAwBnD,QAAMrG,OAAOyJ,SAAS3D,GAClD,GAAIO,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,mBAAoB,CAC3D,IAAMmG,EAAUnG,EAAOoG,QAAQD,QAC/BH,EAAcK,6BAA+BF,EAAQE,6BACrDL,EAAcrD,+BAAiCwD,EAAQxD,+BACvDqD,EAAchD,+BAAiCmD,EAAQnD,+BACvDT,EAAQI,+BAAiCqD,EAAcrD,+BACvDJ,EAAQS,+BAAiCgD,EAAchD,+BAErDH,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,uBACrB6C,QAAMrG,OAAO8J,gBAAgBtG,EAAQ,sBACtC,IACfgG,EAAcO,UAAUC,cAAgBxG,EAAOoG,QAAQK,YAuB3D,GApBI5D,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,6BACvCgG,EAAcU,gBAAkB7D,QAAMrG,OAAO8J,gBAAgBtG,EAAQ,4BAEnE6C,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,kCACvCgG,EAAcO,UAAUI,yBAA2B3G,EAAO4G,IAAID,0BAE5D9D,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,uCACvCgG,EAAcO,UAAUM,8BAAgC7G,EAAO4G,IAAIC,+BAEjEhE,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,2BACvCgG,EAAcO,UAAUO,kBAAoB9G,EAAO4G,IAAIE,mBAErDjE,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,UACvCgG,EAAcO,UAAUQ,qBAAuB/G,EAAOoC,KAAK2E,qBAC3Df,EAAcO,UAAUS,wBAA0BhH,EAAOoC,KAAK4E,wBAC9DhB,EAAcO,UAAUU,+BAAiCjH,EAAOoC,KAAK6E,+BACrEjB,EAAcO,UAAUW,wBAA0BlH,EAAOoC,KAAK8E,wBAC9DlB,EAAcO,UAAUY,+BAAiCnH,EAAOoC,KAAK+E,gCAGnEtE,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,OAAQ,CAC/C,IAAM4G,EAAM5G,EAAO4G,IACQ,kBAAhBA,EAAIQ,UACbpB,EAAcY,IAAIQ,QAAUR,EAAIQ,SAEM,kBAA7BR,EAAIS,uBACbrB,EAAcO,UAAUc,qBAAuBT,EAAIS,sBAEjDT,EAAIU,2BACNtB,EAAcO,UAAUgB,uBAAyBX,EAAIU,0BAEnDV,EAAIY,cACN3E,QAAMrG,OAAOiL,mBAAmBzB,EAAe,mBAAoBY,EAAIY,cAU3E,OAPI3E,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,8BACvCgG,EAAcO,UAAUmB,eAAiB7E,QAAMrG,OAAO8J,gBAAgBtG,EAAQ,6BAE5E6C,QAAMrG,OAAO0J,gBAAgBlG,EAAQ,+BACvC6C,QAAMrG,OAAOqJ,UAAUG,EAAcO,UAAWvG,EAAO2H,SAASxB,QAAQyB,MAAMC,KAEhF7B,EAAcd,QAAUlF,EAAOkF,QACxB,IAAI7E,KAAK+C,EAAcC,EAAQ2C,I,EAUjC8B,YAAP,SAAmBC,GACjB,IAAIC,EACkB,iBAAbD,IAAwB5E,EAAW8E,cAAcC,SAASH,EAASI,gBAAkBhF,EAAWiF,kBAEzG,OADAjF,EAAWG,QAAQC,MAAM,mCAAqCwE,EAAW,OAASC,EAAeK,YAC1FL,G,EASFM,WAAP,WAEE,OADAnF,EAAWG,QAAQiF,KAAK,+BACjB,G,EASFC,YAAP,WACE,IAAIC,EAAiB1K,IAAMyK,cAE3B,OADArF,EAAWG,QAAQC,MAAM,eAAiBkF,GACnCA,G,iCAsBT3C,MAAA,WACMzF,KAAK4E,QAAQoB,+BACfhG,KAAK4E,QAAQsB,UAAb,QAAoChE,GAEtClC,KAAKqI,mBACLrI,KAAKsI,KAAO,IAAI5K,IAAMsC,KAAK4E,QAAQsB,WACnClG,KAAKuI,cAAcC,YAAa,EAChCxI,KAAKsI,KAAKjC,gBAAkBrG,KAAK4E,QAAQyB,gBACzCrG,KAAKyI,gB,EAGPJ,iBAAA,WAAyB,WAsCvB,GArCmF,mBAAxE7F,QAAMrG,OAAO8J,gBAAgBjG,KAAK4E,QAAS,2BACpD9B,EAAWG,QAAQC,MAAM,2BACzBV,QAAMrG,OAAOqJ,UAAUxF,KAAK4E,QAAQsB,UAAW,CAC7CxG,SACAY,SAAU,SAACR,EAAKS,EAAKR,GACnB,IAAI2I,EACEC,EAA6B,CAACpI,MAAKqI,KAAM,KAAMC,QAAS,IAC9D,IACuB,aAAjB9I,EAAQwC,OACVmG,EAAuB,EAAK9D,QAAQC,QAAQiE,cAAcC,cAAY/K,SAAU2K,IAE9E5I,EAAQiJ,MAA8B,aAAtBjJ,EAAQiJ,KAAKzG,OAC/BmG,EAAuB,EAAK9D,QAAQC,QAAQiE,cAAcC,cAAYE,QAASN,IAEjF,MAAO5D,GACP2D,EAAuB/H,QAAQC,OAAOmE,GAGxC,OADA2D,EAAuBA,GAAwB/H,QAAQE,QAAQ8H,IAE5D7H,MAAK,SAAAoI,GACJnJ,EAAQQ,IAAM2I,EAAe3I,IAC7BT,EAAIW,KAAK,MAAOyI,EAAe3I,KAAK,GACpCpE,OAAOgN,QAAQD,EAAeL,SAASO,SAAQ,SAAAC,GAC7CvJ,EAAIkB,iBAAJ,MAAAlB,EAAwBuJ,MAEoB,kBAAnCH,EAAeI,kBACxBxJ,EAAIwJ,gBAAkBJ,EAAeI,oBAGxC3H,OAAM,SAAAoD,GAEL,MADA,EAAKwE,qBAAsB,EACrBxE,SAMoE,mBAAzEvC,QAAMrG,OAAO8J,gBAAgBjG,KAAK4E,QAAS,0BAA0C,CAC9F,IAAM4E,EAAOxJ,KACb8C,EAAWG,QAAQC,MAAM,4BACzBV,QAAMrG,OAAOqJ,UAAUxF,KAAK4E,QAAQsB,UAAW,CAC7CxG,SACAE,iBAAkB,SAAU6J,GAAO,WAC7B3J,EAAM2J,EAAMC,cACdhJ,EAAaZ,EAAIY,WACjBR,EAAQF,KAAKE,MACbH,EAAUC,KAAKD,QACfJ,EAASK,KAAKL,OAGhB,IAAIO,EAAMyJ,SAKNjJ,GAAc,EAAG,CAEnBvF,OAAOyO,aAAa5J,KAAKsB,gBAFN,IAGZuI,EAAW3J,EAAX2J,QAKP,GAJsB,IAAlBA,EAAQC,QACVD,EAAQC,MAAQC,KAAKC,IAAIC,YAAYC,MAAOL,EAAQM,QAGnC,IAAfzJ,EAAkB,CACpB,IAAIoB,EAAShC,EAAIgC,OAEjB,GAAIA,GAAU,KAAOA,EAAS,IAAK,CAEjC,IAAIe,EAAMuH,EADVP,EAAQQ,IAAMN,KAAKC,IAAI9J,EAAMC,OAAQ8J,YAAYC,OAI/CE,EAF2B,gBAAzBrK,EAAQsB,cACVwB,EAAO/C,EAAIwK,UACAC,YAEX1H,EAAO/C,EAAI0K,cACAC,OAEbvK,EAAME,OAASF,EAAMwK,MAAQN,EAE7B,IAMIO,EANEC,EAA+B,CACnCrK,IAAKT,EAAI+K,YACTC,YAAa/K,EAAQQ,IACrBsC,OACAgG,QAASrG,QAAMC,KAAKsI,2BAA2BjL,EAAIkL,0BAGrD,IACuB,aAAjBjL,EAAQwC,OACVoI,EAAwBnB,EAAK5E,QAAQC,QAAQoG,eAAelC,cAAY/K,SAAU4M,IAEhF7K,EAAQiJ,MAA8B,aAAtBjJ,EAAQiJ,KAAKzG,OAC/BoI,EAAwBnB,EAAK5E,QAAQC,QAAQoG,eAAelC,cAAYE,QAAS2B,IAEnF,MAAO7F,GACP4F,EAAwBhK,QAAQC,OAAOmE,GAGzC,OADA4F,EAAwBA,GAAyBhK,QAAQE,QAAQ+J,IAE9D9J,MAAK,SAAAoK,GACJ,EAAKtJ,UAAUuJ,UAAUD,EAAiBhL,EAAOH,EAASD,MAE3D6B,OAAM,SAAAoD,GACLyE,EAAK4B,sBAAuB,EAC5B,EAAKxJ,UAAUC,QAAQ,CAAC5D,KAAM6D,EAAQC,KAAMgD,EAAM/C,SAAUjC,EAASD,MAIrEI,EAAMmL,OAAS1L,EAAO2L,UAAaxJ,GAAU,KAAOA,EAAS,KAC/DgB,EAAWG,QAAQ8B,MAASjD,EAA5B,kBAAoD/B,EAAQQ,KAC5DP,KAAK4B,UAAUC,QAAQ,CAAC5D,KAAM6D,EAAQC,KAAMjC,EAAIyL,YAAaxL,EAASD,KAGtEgD,EAAWG,QAAQiF,KAAQpG,EAA3B,kBAAmD/B,EAAQQ,IAA3D,iBAA+EP,KAAKwL,WAApF,OAEAxL,KAAKuF,UAELvF,KAAKyL,aAAetQ,OAAOoG,WAAWvB,KAAKH,aAAa5C,KAAK+C,MAAOA,KAAKwL,YAEzExL,KAAKwL,WAAazB,KAAK2B,IAAI,EAAI1L,KAAKwL,WAAY7L,EAAOgM,eACvDzL,EAAMmL,cAKVrL,KAAKsB,eAAiBnG,OAAOoG,WAAWvB,KAAKwB,YAAYvE,KAAK+C,MAAOL,EAAO8B,e,EAcxFgH,aAAA,WAAqB,WACnBzI,KAAK4L,sBAAwB,IAAIjL,SAAQ,SAAAE,GAAO,OAAK,EAAKuD,iBAAmBvD,KAC7E,cAAgC1E,OAAOgN,QAAQnJ,KAAK6L,wBAApD,eAA6E,YAAjEpC,EAAiE,KAA1DpH,EAA0D,KAC3ErC,KAAKsI,KAAKwD,GAAGrC,EAAOpH,GAEtBrC,KAAK+L,qBAAuB,kBAAM,EAAKC,gBACvChM,KAAKiM,YAAcjM,KAAKiM,YAAYhP,KAAK+C,MACzCA,KAAKkM,cAAcC,OAAOnM,KAAKoM,cAAe,WAAYpM,KAAKiM,aAC/DjM,KAAKoM,cAAcC,WAAWC,WAAatM,KAAKiM,a,EAGlDnI,WAAA,SAAWjB,GACT7C,KAAKqF,SAASC,YAAUzB,SAAUhB,I,EAGpCmB,uBAAA,SAAuBnB,GAAoB,MACzC7C,KAAKqF,SAAS,yBAA0BxC,GACxC,IAAM0J,EAAWC,MAAMC,KAAN,SAAWzM,KAAKoM,oBAAhB,EAAW,EAAoBC,YAAYK,MAAK,SAAAC,GAAK,MAAoB,QAAhBA,EAAMC,SAC1EC,EAAUL,MAAMC,MAAa,MAARF,OAAA,EAAAA,EAAUO,OAAQ,IACvCC,EAAU,GACZ,MAAJlK,KAAMmK,QAAQ5D,SAAQ,SAAA6D,GACpB,IAAMC,EAAM1K,QAAM2K,aAAaN,GAAS,SAAAK,GAAG,OAAIA,EAAI9G,UAAY6G,EAAOG,OACtE,GAAIF,EAAK,CACP,IAAMG,EAA+BC,8BAAoBJ,GACzDH,EAAQQ,KAAKF,OAGbN,EAAQtC,QACVzK,KAAKqF,SAASC,YAAUkI,qBAAsB,CAACV,KAAMC,K,EAIzDd,YAAA,SAAYxC,GACV,IAAKzJ,KAAKsI,KAAKmF,eAAehD,OAAQ,CAEpC,IAAMiD,EAAe1N,KAAK2N,mBAAmBlE,EAAMkD,OAC/Ce,IACF5K,EAAWG,QAAQC,MAAM,uCAAwCwK,GACjE1N,KAAK4N,cAAcL,KAAKG,GACxB1N,KAAKqF,SAASC,YAAUuI,eAAgB,CAACC,OAAQ9N,KAAK4N,mB,EAU5DG,kBAAA,WACO/N,KAAKsI,OACJtI,KAAKoM,eAAiBpM,KAAKoM,cAAc4B,MAC3CxL,QAAMyL,IAAIC,aAAalO,KAAKoM,cAAe,MAAO,IAClD5J,QAAMyL,IAAIE,gBAAgBnO,KAAKoM,cAAe,QAEhDpM,KAAKyF,U,EAST2I,kBAAA,WACiB,MAAXpO,KAAKsI,OAE8C,IAAjDyB,KAAKsE,MAAMrO,KAAKsO,SAAWtO,KAAKuO,aAClCvO,KAAK4E,QAAQsB,UAAUC,cAAgB,EAC9BnG,KAAKuO,YAAc,IAC5BvO,KAAK4E,QAAQsB,UAAUC,cAAgBnG,KAAKuO,aAE9CvO,KAAKwO,SAEL,SAAAxO,KAAKyO,uBAAL,EAA2B7N,OACzB,IAAIoE,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASa,OAAQoG,QAAQ9G,KAAKwQ,sBAAuB,iCAEtG1O,KAAKyO,qBAAuB,KAC5BzO,KAAK2O,aAAe,KACpB3O,KAAKsI,KAAO,O,EAUhBsG,iBAAA,SAAiB7J,GACf,OAAIA,EAAM9G,OAAS8G,EAAM8J,mBACvB/L,EAAWG,QAAQC,MACjB,8HACA6B,EAAM/C,SAEDhC,KAAK8O,sB,EAahB1M,KAAA,SAAKgE,GAAqC,WAQxC,OAPKpG,KAAK2O,eACR3O,KAAK+O,WAAa3I,EAClBpG,KAAK2O,aAAe,IAAIhO,SAAQ,SAACE,EAASD,GACxC,EAAK6N,qBAAuB,CAAC5N,UAASD,UACtC,EAAKoO,oBAGFhP,KAAK2O,c,EASdK,cAAA,WAKS,MAJHhP,KAAKsI,MAAQtI,KAAKiP,YAAcjP,KAAKiP,WAAW1O,KAClDP,KAAKsI,KAAK4G,WAAWlP,KAAKiP,WAAW1O,KACrCP,KAAKsI,KAAK6G,YAAYnP,KAAKoM,eAC3BpM,KAAKqF,SAASC,YAAU8J,iBAAkB,CAACxS,KAAMoD,KAAKqP,2BAA6B,OAAS,YAE5F,SAAArP,KAAKyO,uBAAL,EAA2B7N,OACzB,IAAIoE,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASa,OAAQoG,QAAQ9G,KAAKwQ,sBAAuB,qB,EAW1GY,0BAAA,WAEEtP,KAAKuP,0BAA2B,EAEhCvP,KAAKwO,SAELxO,KAAK4E,QAAQsB,UAAb,QAAoChE,EACpClC,KAAKsI,KAAO,IAAI5K,IAAMsC,KAAK4E,QAAQsB,WACnClG,KAAKyI,eACLzI,KAAKgP,iB,EASPzJ,QAAA,WAAsB,WACpB,OAAO,IAAI5E,SAAQ,SAACE,EAASD,GAC3B,YAAM2E,QAAN,QAAgBzE,MACd,WAAM,MACJgC,EAAWG,QAAQC,MAAM,WACzB,EAAK0K,cAAgB,GACrB,EAAK4B,qBAAuB,GAC5B,EAAK7K,uBAAyB,EAC9B,EAAKD,mBAAqB,EAC1B,WAAK+J,uBAAL,EAA2B7N,OACzB,IAAIoE,QACFA,QAAQC,SAASC,SACjBF,QAAQjH,SAASa,OACjBoG,QAAQ9G,KAAKwQ,sBACb,iDAGJ,EAAKD,qBAAuB,KAC5B,EAAKE,aAAe,KACpB,EAAKH,SACL3N,OAEF,kBAAMD,W,EAUZ4N,OAAA,WACExO,KAAKyP,kBACLzP,KAAKuJ,qBAAsB,EAC3BvJ,KAAKoL,sBAAuB,EAC5BpL,KAAKsI,KAAKoH,cACV1P,KAAKsI,KAAK/C,W,EAQZoK,aAAA,WACE,IAAMC,EAAc5P,KAAK6P,kBAAkB7P,KAAKsI,KAAKsH,aAAe,IAC9DE,EAAc9P,KAAK+P,kBAAkB/P,KAAKsI,KAAK0H,QAAU,IACzD3D,EAAarM,KAAKiQ,iBAAiBjQ,KAAKsI,KAAKmF,gBAAkB,IACrE,OAAOmC,EAAYM,OAAOJ,GAAaI,OAAO7D,I,EAShDwD,kBAAA,SAAkBM,GAEhB,IADA,IAAIP,EAAc,GACTnU,EAAI,EAAGA,EAAI0U,EAAe1F,OAAQhP,IAAK,CAE9C,IAAI2U,EAAW,CACbC,GAAIF,EAAe1U,GAAG4U,GACtBC,OAAQtQ,KAAKsI,KAAKiI,aAAeJ,EAAe1U,GAAG4U,GACnDzD,MAAOuD,EAAe1U,GAAGO,KACzBwU,SAAUL,EAAe1U,GAAGgV,KAC5BC,MAAOjV,GAETmU,EAAYrC,KAAK,IAAIoD,aAAWP,IAElC,OAAOR,G,EASTG,kBAAA,SAAkBa,GAEhB,IADA,IAAId,EAAc,GACTrU,EAAI,EAAGA,EAAImV,EAAenG,OAAQhP,IAAK,CAE9C,IAAI2U,EAAW,CACbE,OAAQtQ,KAAKsI,KAAKuI,aAAepV,EACjCqV,UAAWF,EAAenV,GAAGsV,QAC7BC,MAAOJ,EAAenV,GAAGuV,MACzBC,OAAQL,EAAenV,GAAGwV,OAC1BT,SAAU,GACVE,MAAOjV,GAETqU,EAAYvC,KAAK,IAAI2D,aAAWd,IAElC,OAAON,G,EASTG,iBAAA,SAAiBkB,GAEf,IADA,IACA,EADI9E,EAAa,GACjB,IAA2B8E,KAA3B,aAA0C,KAA/BC,EAA+B,QAEpChB,EAAW,CACbC,GAAIe,EAAaf,GACjBC,OAAQc,EAAaC,QACrBzE,MAAOwE,EAAapV,KACpBsV,KAAMF,EAAa7O,KAAKuF,cACxB0I,SAAUY,EAAaX,MAEzBpE,EAAWkB,KAAK,IAAIgE,YAAUnB,IAEhC,OAAO/D,G,EASTsB,mBAAA,SAAmBD,GACjB,IAAI8D,EAAY,KAChB,GAA0B,aAAtB9D,EAAa4D,KAAqB,CACpC,IAAMlB,EAAW,CACfC,GAAI3C,EAAa2C,GACjBC,OAA8B,YAAtB5C,EAAa9Q,KACrBgQ,MAAOc,EAAad,MACpB0E,KAAM5D,EAAa4D,KACnBd,SAAU9C,EAAa8C,UAEzBgB,EAAY,IAAID,YAAUnB,GAC1BpQ,KAAKwP,qBAAqBgC,EAAUd,OAAShD,EAE/C,OAAO8D,G,EAUTC,iBAAA,SAAiBlB,GACXA,aAAsBI,eAAeJ,EAAWD,QAAUtQ,KAAKsI,KAAKsH,cACtE5P,KAAKsI,KAAKiI,WAAaA,EAAWF,K,EAWtCqB,iBAAA,SAAiBC,GACXA,aAAsBT,gBAAgBS,EAAWrB,QAAUtQ,KAAKqP,6BAA+BrP,KAAKsI,KAAK0H,SACvGhQ,KAAKqP,4BACPrP,KAAKqF,SAASC,YAAU8J,iBAAkB,CAACxS,KAAM,WAEnDoD,KAAKsI,KAAKsJ,aAAeD,EAAWjB,Q,EAWxCmB,gBAAA,SAAgBL,GACVA,aAAqBD,cAAcC,EAAUlB,QAAUtQ,KAAKsI,OAC1DtI,KAAKsI,KAAKmF,eAAehD,QAC3BzK,KAAKsI,KAAKwJ,cAAgBN,EAAUnB,GACpCrQ,KAAK+R,oBAAoBP,IAEzBxR,KAAKgS,uBAAuBR,K,EAYlCQ,uBAAA,SAAuBR,GACrB,IAAMS,EAAgBjS,KAAKwP,qBAAqBgC,EAAUd,OACtDuB,IACFjS,KAAKkS,0BACLD,EAAcrV,KAAOoD,KAAK4E,QAAQyB,gBAAkB,UAAY,SAChErG,KAAK+R,oBAAoBP,K,EAI7BO,oBAAA,SAAoBP,GAClBxR,KAAKmS,gBAAgBX,I,EAQvBY,cAAA,WACMpS,KAAKsI,OACHtI,KAAKsI,KAAKmF,eAAehD,OAC3BzK,KAAKsI,KAAKwJ,eAAiB,EAE3B9R,KAAKkS,4B,EAWXG,sBAAA,WACOrS,KAAKqP,6BACRrP,KAAKqF,SAASC,YAAU8J,iBAAkB,CAACxS,KAAM,SACjDoD,KAAKsI,KAAKgK,WAAa,I,EAU3BjD,yBAAA,WACE,QAAIrP,KAAKsI,MACAtI,KAAKsI,KAAKiK,kB,EAarBC,oBAAA,SAAoBrL,GAClB3E,QAAMrG,OAAOiL,mBAAmBpH,KAAK4E,QAAS,mBAAoBuC,GAC7DnH,KAAKsI,KAAKtB,sBACbhH,KAAKyS,2BAA2BtL,I,EAUpCuL,iBAAA,WACE,IAAMC,EACJ3S,KAAKsI,KAAK0H,OAAOhQ,KAAKsI,KAAKsJ,eAC3B5R,KAAKsI,KAAK0H,OAAOhQ,KAAKsI,KAAKgK,YAC3BtS,KAAKsI,KAAK0H,OAAOhQ,KAAKsI,KAAKsK,gBAC3B5S,KAAKsI,KAAK0H,OAAOhQ,KAAKsI,KAAKuK,eAC7B,OAAOF,GAASA,EAAMlO,QAAUkO,EAAMlO,QAAU,I,EAQlDqO,aAAA,WACE,IACE,IAAIC,EAQJ,OANEA,EADE/S,KAAKsI,KAAK0K,iBACDhT,KAAKsI,KAAK0K,iBACZhT,KAAKsI,KAAK3I,OAAOsT,iBACfjT,KAAKoM,cAAckC,SAAWtO,KAAKsI,KAAK3I,OAAOsT,iBAE/CjT,KAAKoM,cAAckC,SAAWtO,KAAKsI,KAAK3I,OAAOuT,sBAAwBlT,KAAK0S,mBAAmBS,gBAE1F,EAAIJ,EAAW/S,KAAKoM,cAAckC,SACpD,MAAO9N,GAEP,OADAsC,EAAWG,QAAQC,MAAM,uDAClBlD,KAAKoM,cAAckC,W,EAU9B8E,eAAA,WACE,IACEpT,KAAKoM,cAAcmC,YAAcvO,KAAK8S,eACtC,MAAOtS,GACP,S,EAQJ6S,mBAAA,WACE,IAAMC,EAAc9Q,QAAMrG,OAAO8J,gBAAgBjG,KAAKsI,KAAM,gCAC5D,OAAOgL,EAAcA,EAAYhF,SAAW,G,EAiB9C/J,OAAA,WACE,IACE,QAASvE,KAAK0S,mBAAmBa,KACjC,MAAO/S,GACP,OAAO,I,EAWXgD,kBAAA,SAAkBX,GAAiB,WACjCC,EAAWG,QAAQC,MAAM,2CACpBlD,KAAKsI,KAAK3I,OAAO6T,eACpBxT,KAAKsI,KAAKmL,UAAUzT,KAAK+O,YAE3B/O,KAAK4N,cAAgB5N,KAAK2P,eAErB3P,KAAK4E,QAAQ2B,IAAIQ,UACpB/G,KAAKsI,KAAKsJ,aAAe,GAE3B5R,KAAK4L,sBAAsB9K,MAAK,WAAM,MACpC,WAAK2N,uBAAL,EAA2B5N,QAAQ,CAACiN,OAAQ,EAAKF,gBACjD,EAAKa,qBAAuB,QAZG,IAc1B5E,EAAWhH,EAAK3C,MAAhB2J,QACD6J,EAAuB7J,EAAQQ,IAAMR,EAAQM,MACnDnK,KAAKqF,SAASC,YAAU/B,gBAAiB,CAACoQ,YAAaD,K,EASzDjB,2BAAA,SAA2BtL,GACzB,IAAM2I,EAAc9P,KAAK4N,cAAcgG,QAAO,SAAAjH,GAAK,OAAIA,aAAiBuE,gBAClE2C,EAAkBC,oCAA0BhE,EAAa3I,GAC/D,GAAI0M,EAAgBpJ,OAAQ,CAC1B,IAAMsJ,EAAWF,EAAgB,GAC3BG,EAAWH,EAAgBI,MACjCjU,KAAKsI,KAAK3I,OAAOuU,eAAiBH,EAASjD,UAC3C9Q,KAAKsI,KAAK6L,iBAAmBH,EAAStD,MAEtC,IAAM0D,EAAqBP,EAAgBQ,MAAK,SAAA1H,GAAK,OAAIA,EAAM2D,UAC1DtQ,KAAKqP,4BAA+B+E,GACvCpU,KAAK0R,iBAAiBqC,QAGxBjR,EAAWG,QAAQiF,KAAK,4E,EAY5BxE,iBAAA,SAAiB+F,EAAe5G,GAC9B,IAAI8O,EAAa3R,KAAK4N,cAAclB,MAAK,SAAAC,GACvC,OAAOA,aAAiBuE,cAAcvE,EAAM+D,QAAU7N,EAAK8P,SAE7D3S,KAAKmS,gBAAgBR,I,EAWvB/N,sBAAA,SAAsB6F,EAAe5G,GACnC,IAAI0N,EAAavQ,KAAK4N,cAAclB,MAAK,SAAAC,GACvC,OAAOA,aAAiBgE,cAAchE,EAAM0D,KAAOxN,EAAKwN,MAE1DrQ,KAAKmS,gBAAgB5B,GACrBvQ,KAAKsU,sC,EAUPA,mCAAA,WAA2C,WAEzC,GADyB,CAAC,KAAM,QACXzM,SAAS0M,MAAIC,QAAQxY,MAAO,CAI/CgE,KAAKkM,cAAcuI,WAAWzU,KAAKoM,cAAe9G,YAAUoP,aAHjC,WACzB,EAAKrP,SAASC,YAAUqP,c,EAY9BC,oBAAA,SAAoB/R,GAClB,IAAIgS,EAAkB,GAEtB,OADAA,EAAgB7Y,KAAO6G,EAAK4B,QACpBoQ,EAAgB7Y,MACtB,KAAK0B,IAAMC,aAAaC,oBACxB,KAAKF,IAAMC,aAAaa,iBACxB,KAAKd,IAAMC,aAAamX,uBACtBD,EAAgBtU,IAAMsC,EAAKtC,IAC3BsU,EAAgBE,aAAelS,EAAKyH,SAAWzH,EAAKyH,SAASrM,KAAO,KACpE,MACF,KAAKP,IAAMC,aAAaS,sBACxB,KAAKV,IAAMC,aAAae,mBACxB,KAAKhB,IAAMC,aAAaqX,yBACtBH,EAAgBtU,IAAMsC,EAAKtC,IAC3B,MACF,KAAK7C,IAAMC,aAAaW,uBACtBuW,EAAgBtU,IAAMsC,EAAKtC,IAC3BsU,EAAgBI,OAASpS,EAAKoS,OAC9B,MACF,KAAKvX,IAAMC,aAAagB,mBACtBkW,EAAgBlC,MAAQ9P,EAAK8P,MAC7BkC,EAAgBI,OAASpS,EAAKoS,OAC9B,MACF,KAAKvX,IAAMC,aAAamB,gBACtB+V,EAAgBK,QAAUrS,EAAKmG,KAAOnG,EAAKmG,KAAKzI,IAAM,KACtDsU,EAAgBE,aAAelS,EAAKyH,SAAWzH,EAAKyH,SAASrM,KAAO,KACpE,MACF,KAAKP,IAAMC,aAAaqB,kBACtB6V,EAAgBK,QAAUrS,EAAKmG,KAAOnG,EAAKmG,KAAKzI,IAAM,KACtD,MACF,KAAK7C,IAAMC,aAAawX,mBACxB,KAAKzX,IAAMC,aAAasB,mBACtB4V,EAAgBI,OAASpS,EAAKoS,OAC9B,MACF,KAAKvX,IAAMC,aAAayX,eACtBP,EAAgBQ,qBAAuBxS,EAAKmG,MAAQnG,EAAKmG,KAAKsM,YAAczS,EAAKmG,KAAKsM,YAAY1S,IAAM,KACxGiS,EAAgBE,aAAelS,EAAKyH,SAAWzH,EAAKyH,SAASrM,KAAO,KACpE,MACF,KAAKP,IAAMC,aAAa4X,iBACtBV,EAAgBQ,qBAAuBxS,EAAKmG,MAAQnG,EAAKmG,KAAKsM,YAAczS,EAAKmG,KAAKsM,YAAY1S,IAAM,KACxG,MACF,KAAKlF,IAAMC,aAAa6X,uBACtBX,EAAgBnN,SAAW7E,EAAK6E,SAChCmN,EAAgBY,SAAW5S,EAAK6S,IAAM7S,EAAK6S,IAAI1T,QAAU,KACzD,MACF,KAAKtE,IAAMC,aAAa6B,qBACtBqV,EAAgBc,OAAS9S,EAAK8S,OAMlC,OAHI3V,KAAKuJ,qBAAuBvJ,KAAKoL,wBACnCyJ,EAAgBI,OAASpS,EAAKyH,SAASvI,MAElC8S,G,EASTvR,SAAA,SAAST,GACP,IAAM+S,EAAY/S,EAAKN,KACjBsT,EAAYhT,EAAK4B,QACjBqR,EAAajT,EAAKkT,MACpBlB,EAAkB7U,KAAK4U,oBAAoB/R,GAC/C,GAAIiT,EAAY,CACd,IAAI/Q,EACJ,OAAQ6Q,GACN,KAAKlY,IAAMsY,WAAWC,cAElB,IAAIhY,EAEFA,EADE+B,KAAKuJ,oBACAvE,QAAQ9G,KAAKgY,qBACXlW,KAAKoL,qBACPpG,QAAQ9G,KAAKiY,sBAEbnR,QAAQ9G,KAAKC,YAGpB,CAACT,IAAMC,aAAaC,oBAAqBF,IAAMC,aAAaS,uBAAuByJ,SAASgO,IAC3F7V,KAAKuP,0BACLvP,KAAK4E,QAAQoB,8BACbhG,KAAKuJ,qBACLvJ,KAAKoL,qBAKNrG,EAAQ,IAAIC,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASU,QAASR,EAAM4W,IAH/E9P,EAAQ,IAAIC,QAAQA,QAAQC,SAASmR,YAAapR,QAAQjH,SAASU,QAASR,EAAM4W,GAClF7U,KAAKsP,6BAKT,MACF,KAAK5R,IAAMsY,WAAWK,YAElBtR,EADE/E,KAAK8O,oBACC,IAAI9J,QAAQA,QAAQC,SAASmR,YAAapR,QAAQjH,SAASmB,MAAO8F,QAAQ9G,KAAKwQ,sBAAuBmG,GAEtG,IAAI7P,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASmB,MAAO8F,QAAQ9G,KAAKwQ,sBAAuBmG,GAE7G,MACF,QACE9P,EAAQ,IAAIC,QAAQA,QAAQC,SAASC,SAAUF,QAAQjH,SAASa,OAAQoG,QAAQ9G,KAAKwQ,sBAAuBmG,GAIhH,GADA7U,KAAKqF,SAASC,YAAUjC,MAAO0B,GAC3BA,GAASA,EAAMuR,WAAatR,QAAQC,SAASC,SAAU,CAC1B,MAA/B,GAAIlF,KAAKyO,qBACP,SAAAzO,KAAKyO,uBAAL,EAA2B7N,OAAOmE,GAClC/E,KAAKyO,qBAAuB,KAC5BzO,KAAK2O,aAAe,KAEtB3O,KAAKuF,eAEF,OAEHvF,KAAKuJ,qBAAuBvJ,KAAKoL,qBAC7B,CACEvN,SAAUmH,QAAQjH,SAASU,QAC3BR,KAAM+B,KAAKuJ,oBAAsBvE,QAAQ9G,KAAKgY,qBAAuBlR,QAAQ9G,KAAKiY,uBAEpF1Y,EAAcoY,IAAc,CAAChY,SAAU,EAAGI,KAAM,GAN/CJ,EADF,EACEA,SAAUI,EADZ,EACYA,KAOjB6E,EAAWG,QAAQiF,KAAK,IAAIlD,QAAQA,QAAQC,SAASmR,YAAavY,EAAUI,EAAM4W,IAEpF7U,KAAKuJ,qBAAsB,EAC3BvJ,KAAKoL,sBAAuB,G,EAQ9B0D,kBAAA,WACE,IAAM5E,EAAcD,YAAYC,MAC5BqM,GAAU,EAad,OAZIvW,KAAKwW,yBAAyBtM,EAAKlK,KAAKyW,0BAA2BzW,KAAK4E,QAAQ8R,4BAClF1W,KAAKkM,cAAcC,OAAOnM,KAAKoM,cAAe9G,YAAUqR,gBAAiB3W,KAAK+L,sBAC9E/L,KAAK4W,yBAED5W,KAAKwW,yBAAyBtM,EAAKlK,KAAK6W,2BAA4B7W,KAAK4E,QAAQkS,6BACnF9W,KAAKkM,cAAcC,OAAOnM,KAAKoM,cAAe9G,YAAUqR,gBAAiB3W,KAAK+L,sBAC9E/L,KAAK+W,2BAELR,GAAU,EACVzT,EAAWG,QAAQ8B,MAAM,qDAGtBwR,G,EAQTvK,aAAA,WACEhM,KAAKqF,SAASC,YAAU0R,iBACxBhX,KAAKoM,cAAc6K,oBAAoB3R,YAAUqR,gBAAiB3W,KAAK+L,uB,EAWzEyK,yBAAA,SAAyBtM,EAAapJ,EAAcoW,GAClD,OAAQpW,GAAQoJ,EAAMpJ,EAAOoW,G,EAQ/BN,sBAAA,WACE5W,KAAKyW,0BAA4BxM,YAAYC,MAC7CpH,EAAWG,QAAQiF,KAAK,8BACxBlI,KAAKsI,KAAK6O,qB,EAQZJ,uBAAA,WACE/W,KAAK6W,2BAA6B5M,YAAYC,MAC9CpH,EAAWG,QAAQiF,KAAK,mDACxBlI,KAAKsI,KAAK8O,iBACVpX,KAAKsI,KAAK6O,qB,EAQZ1H,gBAAA,WACE,cAAgCtT,OAAOgN,QAAQnJ,KAAK6L,wBAApD,eAA6E,YAAjEpC,EAAiE,KAA1DpH,EAA0D,KAC3ErC,KAAKsI,KAAK+O,IAAI5N,EAAOpH,GAEvBrC,KAAKoM,cAAcC,WAAWC,WAAa,KAC3CtM,KAAK+L,qBAAuB,KACxB/L,KAAKkM,eACPlM,KAAKkM,cAAcoL,a,EASvBC,wBAAA,WACE,IAAIvX,KAAKuE,SAmBP,OAAO,EAlBP,IACE,IACEE,EADoBzE,KAAKsI,KAAK0H,OAAOhQ,KAAKsI,KAAKuK,eACvBpO,QACxB+S,EAAY/S,EAAQ+S,UACpBC,EAAaD,EAAU/M,OACvBN,EAAQqN,EAAU,GAAGrN,MAAQqN,EAAU,GAAGlJ,SAC1CjE,EAAMmN,EAAUC,EAAa,GAAGtN,MAAQqN,EAAUC,EAAa,GAAGnJ,SAClEoJ,OAC8CC,IAA5C3X,KAAKsI,KAAK3I,OAAOiY,uBACb5X,KAAKsI,KAAK3I,OAAOiY,uBACjB5X,KAAKsI,KAAK3I,OAAOkY,4BAA8BpT,EAAQ0O,eAE/D,OADiBpJ,KAAKC,IAAIG,EAAQnK,KAAKsI,KAAK3I,OAAOmY,uBAAwBzN,EAAMqN,GAEjF,MAAOlX,GAEP,OADAsC,EAAWG,QAAQC,MAAM,yCAClB,I,EA4CbgB,cAAA,SAAcrB,GACZ,GAAIL,QAAMrG,OAAO0J,gBAAgBhD,EAAM,sBAAuB,KACrD3C,EAAS2C,EAAKmG,KAAd9I,MACD6X,EAAuB7X,EAAM2J,QAAQQ,IAAMnK,EAAM2J,QAAQM,MAC/DnK,KAAKqF,SAASC,YAAUrB,YAAa,CACnC0P,YAAaoE,EACbC,MAAO9X,EAAME,OACbG,IAAKsC,EAAKmG,KAAKzI,Q,EAuBrB0X,qBAAA,WAEE,OAAIjY,KAAKsI,KAAK3I,OAAOsT,iBACZjT,KAAKsI,KAAK3I,OAAOsT,iBAEjBjT,KAAKsI,KAAK3I,OAAOuT,sBAAwBlT,KAAK0S,mBAAmBS,gB,2CAjb1E,OAAOnT,KAAK8S,eAAiB9S,KAAKqT,uB,mCA+ZlC,IAAI6E,EAAkBC,IACtB,OAAKnY,KAAKsI,MAGR4P,EADElY,KAAKuE,SACWvE,KAAKiY,wBAA0BjY,KAAKoM,cAAcmC,YAAcvO,KAAK8S,gBAGrE9S,KAAKoM,cAAckC,SAAWtO,KAAKoM,cAAcmC,YAErE2J,EAAkBnO,KAAK2B,IAAIwM,EAAiBlY,KAAKsI,KAAK3I,OAAOyY,mBAAqBpY,KAAK0S,mBAAmBS,iBARnFgF,S,8BA5xCaE,0B,EAAnBvV,E,KAOC,c,EAPDA,E,UAcFuV,yBAAuBC,UAAUxV,EAAWuN,K,EAd1CvN,E,gBAqBmB,CACpC,wBACA,gCACA,gBACA,kBACA,kBACA,gBACA,wBChDJ,IAAMyV,EAAUC,SACVC,EAAOC,6BAEE5V,YAIXA,EAAWqF,eACbwQ,qCAA2B7V","file":"playkit-hls.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hls\", [\"playkit-js\", \"hls.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hls\"] = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse\n\t\troot[\"playkit\"] = root[\"playkit\"] || {}, root[\"playkit\"][\"hls\"] = factory(root[\"playkit\"][\"core\"], root[\"Hls\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__1__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","// @flow\nimport Hlsjs from 'hls.js';\nimport {Error} from '@playkit-js/playkit-js';\n\ntype ErrorDetailsType = {category: number, code: number};\ntype HlsJsErrorMapType = {[name: string]: ErrorDetailsType};\n\nconst HlsJsErrorMap: HlsJsErrorMapType = {\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_PARSING_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HLSJS_CANNOT_PARSE\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.LEVEL_SWITCH_ERROR]: {\n    category: Error.Category.PLAYER,\n    code: Error.Code.BITRATE_SWITCH_ISSUE\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOOP_LOADING_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.FRAG_PARSING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_FRAG_PARSING_ERROR\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPEND_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPEND_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPENDING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPENDING_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_STALLED_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_STALLED_ERROR\n  }\n};\n\nexport {HlsJsErrorMap};\nexport type {ErrorDetailsType};\n","//@flow\nimport Hlsjs from 'hls.js';\n\n/**\n * A custom override for the loader function in hls.js.\n * It passes the context for the xhrSetup config\n */\nexport default class loader extends Hlsjs.DefaultConfig.loader {\n  constructor(config: Object) {\n    super(config);\n    if (config && config.readystatechange) {\n      this.readystatechange = config.readystatechange;\n    }\n  }\n\n  loadInternal() {\n    let xhr,\n      context = this.context;\n    xhr = this.loader = new XMLHttpRequest();\n\n    let stats = this.stats;\n    stats.tfirst = 0;\n    stats.loaded = 0;\n    const xhrSetup = this.xhrSetup;\n\n    let xhrSetupPromise;\n    try {\n      if (xhrSetup) {\n        try {\n          xhrSetupPromise = xhrSetup(xhr, context.url, context);\n        } catch (e) {\n          // fix xhrSetup: (xhr, url) => {xhr.setRequestHeader(\"Content-Language\", \"test\");}\n          // not working, as xhr.setRequestHeader expects xhr.readyState === OPEN\n          xhr.open('GET', context.url, true);\n          xhrSetupPromise = xhrSetup(xhr, context.url, context);\n        }\n      }\n      if (!xhr.readyState) {\n        xhr.open('GET', context.url, true);\n      }\n    } catch (e) {\n      // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n      xhrSetupPromise = Promise.reject(e);\n    }\n    xhrSetupPromise = xhrSetupPromise || Promise.resolve();\n    xhrSetupPromise\n      .then(() => {\n        if (context.rangeEnd) {\n          xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n        }\n\n        xhr.onreadystatechange = this.readystatechange.bind(this);\n        xhr.onprogress = this.loadprogress.bind(this);\n        xhr.responseType = context.responseType;\n\n        // setup timeout before we perform request\n        this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout);\n        xhr.send();\n      })\n      .catch(e => {\n        this.callbacks.onError({code: xhr.status, text: e.message}, context, xhr);\n      });\n  }\n}\n","//@flow\nimport {Utils} from '@playkit-js/playkit-js';\nimport loader from './loader';\n\n/**\n * A plugin override for the loader function in hls.js.\n * It checks if it should use jsonp for the manifest first, else - the regular\n * loader is called.\n */\nexport default class pLoader extends loader {\n  /**\n   * redirect external stream handler function\n   * @param {Object} data - The json object that returns from the server.\n   * @param {string} uri - the original uri\n   * @returns {string} uri - the redirected URI\n   * @static\n   */\n  static redirectExternalStreamsHandler: Function = (data, uri) => uri;\n\n  /**\n   * @constructor\n   * @param {Object} config - hlsjs config object. it also contains the jsonp callback function\n   */\n  constructor(config: Object) {\n    super(config);\n    const loadOrig = this.load.bind(this);\n    const callback = pLoader.redirectExternalStreamsHandler;\n    this.load = (context, config, callbacks) => {\n      const url = context.url;\n      if (context.type === 'manifest') {\n        Utils.Http.jsonp(url, callback, {\n          timeout: pLoader.redirectExternalStreamsTimeout\n        })\n          .then(uri => {\n            context.url = uri;\n            loadOrig(context, config, callbacks);\n          })\n          .catch(() => loadOrig(context, config, callbacks));\n      } else {\n        loadOrig(context, config, callbacks);\n      }\n    };\n  }\n}\n","//@flow\nimport Hlsjs from 'hls.js';\nimport DefaultConfig from './default-config';\nimport {type ErrorDetailsType, HlsJsErrorMap} from './errors';\nimport {\n  AudioTrack,\n  BaseMediaSourceAdapter,\n  Env,\n  Error as PKError,\n  EventType,\n  TextTrack,\n  Track,\n  Utils,\n  VideoTrack,\n  RequestType,\n  filterTracksByRestriction,\n  PKABRRestrictionObject,\n  TimedMetadata,\n  createTimedMetadata\n} from '@playkit-js/playkit-js';\nimport pLoader from './jsonp-ploader';\nimport loader from './loader';\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nexport default class HlsAdapter extends BaseMediaSourceAdapter {\n  /**\n   * The id of the adapter.\n   * @member {string} id\n   * @static\n   * @private\n   */\n  static id: string = 'HlsAdapter';\n  /**\n   * The adapter logger.\n   * @member {any} _logger\n   * @static\n   * @private\n   */\n  static _logger = BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\n  /**\n   * The supported mime types by the hls adapter.\n   * @member {Array<string>} _hlsMimeType\n   * @static\n   * @private\n   */\n  static _hlsMimeTypes: Array<string> = [\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    'audio/mpegurl',\n    'audio/x-mpegurl',\n    'video/x-mpegurl',\n    'video/mpegurl',\n    'application/mpegurl'\n  ];\n\n  /**\n   * The Hls lib\n   * @type {any}\n   * @private\n   */\n  _hlsjsLib: any = Hlsjs;\n  /**\n   * The hls player instance.\n   * @member {any} _hls\n   * @private\n   */\n  _hls: any;\n\n  /**\n   * last recover date from decoding error\n   * @type {number}\n   * @private\n   */\n  _recoverDecodingErrorDate: number;\n\n  /**\n   * last recover date from audio swap codec operation\n   * @type {number}\n   * @private\n   */\n  _recoverSwapAudioCodecDate: number;\n\n  /**\n   * indicate if external redirect was performed\n   * @type {boolean}\n   * @private\n   */\n  _triedReloadWithRedirect: boolean = false;\n\n  /**\n   * The load promise\n   * @member {Promise<Object>} - _loadPromise\n   * @type {Promise<Object>}\n   * @private\n   */\n  _loadPromise: ?Promise<Object>;\n\n  /**\n   * the _loadPromise handlers\n   * @member {{resolve: (result: Promise<R> | R) => void, reject: (error: any) => void}} - _loadPromiseHandlers\n   * @type {{resolve: (result: Promise<R> | R) => void, reject: (error: any) => void}}\n   * @private\n   */\n  _loadPromiseHandlers: {resolve: (result: Promise<*> | *) => void, reject: (error: any) => void} | null;\n\n  /**\n   * Reference to the player tracks.\n   * @member {Array<Track>} - _playerTracks\n   * @type {Array<Track>}\n   * @private\n   */\n  _playerTracks: Array<Track> = [];\n  /**\n   * stream start time in seconds\n   * @type {?number}\n   * @private\n   */\n  _startTime: ?number = 0;\n  /**\n   * Reference to _onRecoveredCallback function\n   * @member {?Function} - _onRecoveredCallback\n   * @type {?Function}\n   * @private\n   */\n  _onRecoveredCallback: ?Function;\n  _onAddTrack: Function;\n  _onMediaAttached: Function;\n  _mediaAttachedPromise: Promise<*>;\n  _requestFilterError: boolean = false;\n  _responseFilterError: boolean = false;\n  _nativeTextTracksMap = {};\n  _lastLoadedFragSN: number = -1;\n  _sameFragSNLoadedCount: number = 0;\n  /**\n   * an object containing all the events we bind and unbind to.\n   * @member {Object} - _adapterEventsBindings\n   * @type {Object}\n   * @private\n   */\n  _adapterEventsBindings: {[name: string]: Function} = {\n    [Hlsjs.Events.ERROR]: (e, data) => this._onError(data),\n    [Hlsjs.Events.MANIFEST_LOADED]: (e, data) => this._onManifestLoaded(data),\n    [Hlsjs.Events.LEVEL_SWITCHED]: (e, data) => this._onLevelSwitched(e, data),\n    [Hlsjs.Events.AUDIO_TRACK_SWITCHED]: (e, data) => this._onAudioTrackSwitched(e, data),\n    [Hlsjs.Events.FPS_DROP]: (e, data) => this._onFpsDrop(data),\n    [Hlsjs.Events.FRAG_PARSING_METADATA]: (e, data) => this._onFragParsingMetadata(data),\n    [Hlsjs.Events.FRAG_LOADED]: (e, data) => this._onFragLoaded(data),\n    [Hlsjs.Events.MEDIA_ATTACHED]: () => this._onMediaAttached(),\n    [Hlsjs.Events.LEVEL_LOADED]: (e, data) => this._onLevelLoaded(e, data)\n  };\n\n  /**\n   * Factory method to create media source adapter.\n   * @function createAdapter\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n   * @param {PKMediaSourceObject} source - The source Object.\n   * @param {Object} config - The player configuration.\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n   * @static\n   */\n  static createAdapter(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object): IMediaSourceAdapter {\n    let adapterConfig: Object = Utils.Object.copyDeep(DefaultConfig);\n    if (Utils.Object.hasPropertyPath(config, 'sources.options')) {\n      const options = config.sources.options;\n      adapterConfig.forceRedirectExternalStreams = options.forceRedirectExternalStreams;\n      adapterConfig.redirectExternalStreamsHandler = options.redirectExternalStreamsHandler;\n      adapterConfig.redirectExternalStreamsTimeout = options.redirectExternalStreamsTimeout;\n      pLoader.redirectExternalStreamsHandler = adapterConfig.redirectExternalStreamsHandler;\n      pLoader.redirectExternalStreamsTimeout = adapterConfig.redirectExternalStreamsTimeout;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'sources.startTime')) {\n      const startTime = Utils.Object.getPropertyPath(config, 'sources.startTime');\n      if (startTime > -1) {\n        adapterConfig.hlsConfig.startPosition = config.sources.startTime;\n      }\n    }\n    if (Utils.Object.hasPropertyPath(config, 'text.useNativeTextTrack')) {\n      adapterConfig.subtitleDisplay = Utils.Object.getPropertyPath(config, 'text.useNativeTextTrack');\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedFramesInterval')) {\n      adapterConfig.hlsConfig.fpsDroppedFramesInterval = config.abr.fpsDroppedFramesInterval;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedMonitoringThreshold')) {\n      adapterConfig.hlsConfig.fpsDroppedMonitoringThreshold = config.abr.fpsDroppedMonitoringThreshold;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.capLevelOnFPSDrop')) {\n      adapterConfig.hlsConfig.capLevelOnFPSDrop = config.abr.capLevelOnFPSDrop;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'text')) {\n      adapterConfig.hlsConfig.enableCEA708Captions = config.text.enableCEA708Captions;\n      adapterConfig.hlsConfig.captionsTextTrack1Label = config.text.captionsTextTrack1Label;\n      adapterConfig.hlsConfig.captionsTextTrack1LanguageCode = config.text.captionsTextTrack1LanguageCode;\n      adapterConfig.hlsConfig.captionsTextTrack2Label = config.text.captionsTextTrack2Label;\n      adapterConfig.hlsConfig.captionsTextTrack2LanguageCode = config.text.captionsTextTrack2LanguageCode;\n    }\n\n    if (Utils.Object.hasPropertyPath(config, 'abr')) {\n      const abr = config.abr;\n      if (typeof abr.enabled === 'boolean') {\n        adapterConfig.abr.enabled = abr.enabled;\n      }\n      if (typeof abr.capLevelToPlayerSize === 'boolean') {\n        adapterConfig.hlsConfig.capLevelToPlayerSize = abr.capLevelToPlayerSize;\n      }\n      if (abr.defaultBandwidthEstimate) {\n        adapterConfig.hlsConfig.abrEwmaDefaultEstimate = abr.defaultBandwidthEstimate;\n      }\n      if (abr.restrictions) {\n        Utils.Object.createPropertyPath(adapterConfig, 'abr.restrictions', abr.restrictions);\n      }\n    }\n    if (Utils.Object.hasPropertyPath(config, 'streaming.lowLatencyMode')) {\n      adapterConfig.hlsConfig.lowLatencyMode = Utils.Object.getPropertyPath(config, 'streaming.lowLatencyMode');\n    }\n    if (Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n      Utils.Object.mergeDeep(adapterConfig.hlsConfig, config.playback.options.html5.hls);\n    }\n    adapterConfig.network = config.network;\n    return new this(videoElement, source, adapterConfig);\n  }\n\n  /**\n   * Checks if hls adapter can play a given mime type.\n   * @function canPlayType\n   * @param {string} mimeType - The mime type to check.\n   * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n   * @static\n   */\n  static canPlayType(mimeType: string): boolean {\n    let canHlsPlayType =\n      typeof mimeType === 'string' ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) && HlsAdapter.isMSESupported() : false;\n    HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n    return canHlsPlayType;\n  }\n\n  /**\n   * Checks if hls adapter can play a given drm data.\n   * For hls.js it always returns false.\n   * @returns {boolean} - Whether the hls adapter can play a specific drm data.\n   * @static\n   */\n  static canPlayDrm(): boolean {\n    HlsAdapter._logger.warn('canPlayDrm result is false');\n    return false;\n  }\n\n  /**\n   * Checks if the hls adapter is supported.\n   * @function isSupported\n   * @returns {boolean} - Whether hls is supported.\n   * @static\n   */\n  static isSupported(): boolean {\n    let isHlsSupported = Hlsjs.isSupported();\n    HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n    return isHlsSupported;\n  }\n\n  /**\n   * @constructor\n   * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n   * @param {PKMediaSourceObject} source - The source object\n   * @param {Object} config - The media source adapter configuration\n   */\n  constructor(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object) {\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + Hlsjs.version);\n    super(videoElement, source, config);\n    this._config = Utils.Object.mergeDeep({}, DefaultConfig, this._config);\n    this._init();\n  }\n\n  /**\n   * init the hls adapter\n   * @function _init\n   * @private\n   * @returns {void}\n   */\n  _init(): void {\n    if (this._config.forceRedirectExternalStreams) {\n      this._config.hlsConfig['pLoader'] = pLoader;\n    }\n    this._maybeSetFilters();\n    this._hls = new Hlsjs(this._config.hlsConfig);\n    this._capabilities.fpsControl = true;\n    this._hls.subtitleDisplay = this._config.subtitleDisplay;\n    this._addBindings();\n  }\n\n  _maybeSetFilters(): void {\n    if (typeof Utils.Object.getPropertyPath(this._config, 'network.requestFilter') === 'function') {\n      HlsAdapter._logger.debug('Register request filter');\n      Utils.Object.mergeDeep(this._config.hlsConfig, {\n        loader,\n        xhrSetup: (xhr, url, context) => {\n          let requestFilterPromise;\n          const pkRequest: PKRequestObject = {url, body: null, headers: {}};\n          try {\n            if (context.type === 'manifest') {\n              requestFilterPromise = this._config.network.requestFilter(RequestType.MANIFEST, pkRequest);\n            }\n            if (context.frag && context.frag.type !== 'subtitle') {\n              requestFilterPromise = this._config.network.requestFilter(RequestType.SEGMENT, pkRequest);\n            }\n          } catch (error) {\n            requestFilterPromise = Promise.reject(error);\n          }\n          requestFilterPromise = requestFilterPromise || Promise.resolve(pkRequest);\n          return requestFilterPromise\n            .then(updatedRequest => {\n              context.url = updatedRequest.url;\n              xhr.open('GET', updatedRequest.url, true);\n              Object.entries(updatedRequest.headers).forEach(entry => {\n                xhr.setRequestHeader(...entry);\n              });\n              if (typeof updatedRequest.withCredentials === 'boolean') {\n                xhr.withCredentials = updatedRequest.withCredentials;\n              }\n            })\n            .catch(error => {\n              this._requestFilterError = true;\n              throw error;\n            });\n        }\n      });\n    }\n\n    if (typeof Utils.Object.getPropertyPath(this._config, 'network.responseFilter') === 'function') {\n      const self = this;\n      HlsAdapter._logger.debug('Register response filter');\n      Utils.Object.mergeDeep(this._config.hlsConfig, {\n        loader,\n        readystatechange: function (event) {\n          let xhr = event.currentTarget,\n            readyState = xhr.readyState,\n            stats = this.stats,\n            context = this.context,\n            config = this.config;\n\n          // don't proceed if xhr has been aborted\n          if (stats.aborted) {\n            return;\n          }\n\n          // >= HEADERS_RECEIVED\n          if (readyState >= 2) {\n            // clear xhr timeout and rearm it if readyState less than 4\n            window.clearTimeout(this.requestTimeout);\n            const {loading} = stats;\n            if (loading.first === 0) {\n              loading.first = Math.max(performance.now(), loading.start);\n            }\n\n            if (readyState === 4) {\n              let status = xhr.status;\n              // http status between 200 to 299 are all successful\n              if (status >= 200 && status < 300) {\n                loading.end = Math.max(stats.tfirst, performance.now());\n                let data, len;\n                if (context.responseType === 'arraybuffer') {\n                  data = xhr.response;\n                  len = data.byteLength;\n                } else {\n                  data = xhr.responseText;\n                  len = data.length;\n                }\n                stats.loaded = stats.total = len;\n\n                const pkResponse: PKResponseObject = {\n                  url: xhr.responseURL,\n                  originalUrl: context.url,\n                  data,\n                  headers: Utils.Http.convertHeadersToDictionary(xhr.getAllResponseHeaders())\n                };\n                let responseFilterPromise;\n                try {\n                  if (context.type === 'manifest') {\n                    responseFilterPromise = self._config.network.responseFilter(RequestType.MANIFEST, pkResponse);\n                  }\n                  if (context.frag && context.frag.type !== 'subtitle') {\n                    responseFilterPromise = self._config.network.responseFilter(RequestType.SEGMENT, pkResponse);\n                  }\n                } catch (error) {\n                  responseFilterPromise = Promise.reject(error);\n                }\n                responseFilterPromise = responseFilterPromise || Promise.resolve(pkResponse);\n                return responseFilterPromise\n                  .then(updatedResponse => {\n                    this.callbacks.onSuccess(updatedResponse, stats, context, xhr);\n                  })\n                  .catch(error => {\n                    self._responseFilterError = true;\n                    this.callbacks.onError({code: status, text: error.message}, context, xhr);\n                  });\n              } else {\n                // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n                if (stats.retry >= config.maxRetry || (status >= 400 && status < 499)) {\n                  HlsAdapter._logger.error(`${status} while loading ${context.url}`);\n                  this.callbacks.onError({code: status, text: xhr.statusText}, context, xhr);\n                } else {\n                  // retry\n                  HlsAdapter._logger.warn(`${status} while loading ${context.url}, retrying in ${this.retryDelay}...`);\n                  // aborts and resets internal state\n                  this.destroy();\n                  // schedule retry\n                  this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n                  // set exponential backoff\n                  this.retryDelay = Math.min(2 * this.retryDelay, config.maxRetryDelay);\n                  stats.retry++;\n                }\n              }\n            } else {\n              // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n              this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), config.timeout);\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Adds the required bindings locally and with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n  _addBindings(): void {\n    this._mediaAttachedPromise = new Promise(resolve => (this._onMediaAttached = resolve));\n    for (const [event, callback] of Object.entries(this._adapterEventsBindings)) {\n      this._hls.on(event, callback);\n    }\n    this._onRecoveredCallback = () => this._onRecovered();\n    this._onAddTrack = this._onAddTrack.bind(this);\n    this._eventManager.listen(this._videoElement, 'addtrack', this._onAddTrack);\n    this._videoElement.textTracks.onaddtrack = this._onAddTrack;\n  }\n\n  _onFpsDrop(data: Object): void {\n    this._trigger(EventType.FPS_DROP, data);\n  }\n\n  _onFragParsingMetadata(data: Object): void {\n    this._trigger('hlsFragParsingMetadata', data);\n    const id3Track = Array.from(this._videoElement?.textTracks).find(track => track.label === 'id3');\n    const id3Cues = Array.from(id3Track?.cues || []);\n    const newCues = [];\n    data?.samples.forEach(sample => {\n      const cue = Utils.binarySearch(id3Cues, cue => cue.startTime - sample.pts);\n      if (cue) {\n        const timedMetadata: TimedMetadata = createTimedMetadata(cue);\n        newCues.push(timedMetadata);\n      }\n    });\n    if (newCues.length) {\n      this._trigger(EventType.TIMED_METADATA_ADDED, {cues: newCues});\n    }\n  }\n\n  _onAddTrack(event: any) {\n    if (!this._hls.subtitleTracks.length) {\n      // parse CEA 608/708 captions that not exposed on hls.subtitleTracks API\n      const CEATextTrack = this._parseCEATextTrack(event.track);\n      if (CEATextTrack) {\n        HlsAdapter._logger.debug('A CEA 608/708 caption has been found', CEATextTrack);\n        this._playerTracks.push(CEATextTrack);\n        this._trigger(EventType.TRACKS_CHANGED, {tracks: this._playerTracks});\n      }\n    }\n  }\n\n  /**\n   * attach media - return the media source to handle the video tag\n   * @public\n   * @returns {void}\n   */\n  attachMediaSource(): void {\n    if (!this._hls) {\n      if (this._videoElement && this._videoElement.src) {\n        Utils.Dom.setAttribute(this._videoElement, 'src', '');\n        Utils.Dom.removeAttribute(this._videoElement, 'src');\n      }\n      this._init();\n    }\n  }\n\n  /**\n   * detach media - will remove the media source from handling the video\n   * @public\n   * @returns {void}\n   */\n  detachMediaSource(): void {\n    if (this._hls) {\n      // 1 second different between duration and current time will signal as end - will enable replay button\n      if (Math.floor(this.duration - this.currentTime) === 0) {\n        this._config.hlsConfig.startPosition = 0;\n      } else if (this.currentTime > 0) {\n        this._config.hlsConfig.startPosition = this.currentTime;\n      }\n      this._reset();\n\n      this._loadPromiseHandlers?.reject(\n        new PKError(PKError.Severity.CRITICAL, PKError.Category.PLAYER, PKError.Code.HLS_FATAL_MEDIA_ERROR, 'media detached while loading')\n      );\n      this._loadPromiseHandlers = null;\n      this._loadPromise = null;\n      this._hls = null;\n    }\n  }\n\n  /**\n   * video error event handler.\n   * @param {MediaError} error - the media error\n   * @public\n   * @returns {boolean} if hls-adapter will try to recover\n   */\n  handleMediaError(error: MediaError): boolean {\n    if (error.code === error.MEDIA_ERR_DECODE) {\n      HlsAdapter._logger.debug(\n        'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',\n        error.message\n      );\n      return this._handleMediaError();\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @param {number} startTime - Optional time to start the video from.\n   * @returns {Promise<Object>} - The loaded data\n   * @override\n   */\n  load(startTime: ?number): Promise<Object> {\n    if (!this._loadPromise) {\n      this._startTime = startTime;\n      this._loadPromise = new Promise((resolve, reject) => {\n        this._loadPromiseHandlers = {resolve, reject};\n        this._loadInternal();\n      });\n    }\n    return this._loadPromise;\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @returns {void}\n   * @private\n   */\n  _loadInternal() {\n    if (this._hls && this._sourceObj && this._sourceObj.url) {\n      this._hls.loadSource(this._sourceObj.url);\n      this._hls.attachMedia(this._videoElement);\n      this._trigger(EventType.ABR_MODE_CHANGED, {mode: this.isAdaptiveBitrateEnabled() ? 'auto' : 'manual'});\n    } else {\n      this._loadPromiseHandlers?.reject(\n        new PKError(PKError.Severity.CRITICAL, PKError.Category.PLAYER, PKError.Code.HLS_FATAL_MEDIA_ERROR, 'no url provided')\n      );\n    }\n  }\n\n  /**\n   * Load the video source with installed playlist loader\n   * @function _reloadWithDirectManifest\n   * @returns {void}\n   * @private\n   */\n  _reloadWithDirectManifest() {\n    // Mark that we tried once to redirect\n    this._triedReloadWithRedirect = true;\n    // reset hls.js\n    this._reset();\n    // re-init hls.js with the external redirect playlist loader\n    this._config.hlsConfig['pLoader'] = pLoader;\n    this._hls = new Hlsjs(this._config.hlsConfig);\n    this._addBindings();\n    this._loadInternal();\n  }\n\n  /**\n   * Destroys the hls adapter.\n   * @function destroy\n   * @override\n   * @returns {Promise<*>} - The destroy promise.\n   */\n  destroy(): Promise<*> {\n    return new Promise((resolve, reject) => {\n      super.destroy().then(\n        () => {\n          HlsAdapter._logger.debug('destroy');\n          this._playerTracks = [];\n          this._nativeTextTracksMap = {};\n          this._sameFragSNLoadedCount = 0;\n          this._lastLoadedFragSN = -1;\n          this._loadPromiseHandlers?.reject(\n            new PKError(\n              PKError.Severity.CRITICAL,\n              PKError.Category.PLAYER,\n              PKError.Code.HLS_FATAL_MEDIA_ERROR,\n              'The adapter has been destroyed while loading'\n            )\n          );\n          this._loadPromiseHandlers = null;\n          this._loadPromise = null;\n          this._reset();\n          resolve();\n        },\n        () => reject()\n      );\n    });\n  }\n\n  /**\n   * reset hls.js instance and its bindings\n   * @private\n   * @returns {void}\n   */\n  _reset(): void {\n    this._removeBindings();\n    this._requestFilterError = false;\n    this._responseFilterError = false;\n    this._hls.detachMedia();\n    this._hls.destroy();\n  }\n\n  /**\n   * Parse the hls tracks into player tracks.\n   * @returns {Array<Track>} - The parsed tracks.\n   * @private\n   */\n  _parseTracks(): Array<Track> {\n    const audioTracks = this._parseAudioTracks(this._hls.audioTracks || []);\n    const videoTracks = this._parseVideoTracks(this._hls.levels || []);\n    const textTracks = this._parseTextTracks(this._hls.subtitleTracks || []);\n    return audioTracks.concat(videoTracks).concat(textTracks);\n  }\n\n  /**\n   * Parse hls audio tracks into player audio tracks.\n   * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n   * @returns {Array<AudioTrack>} - The parsed audio tracks.\n   * @private\n   */\n  _parseAudioTracks(hlsAudioTracks: Array<Object>): Array<AudioTrack> {\n    let audioTracks = [];\n    for (let i = 0; i < hlsAudioTracks.length; i++) {\n      // Create audio tracks\n      let settings = {\n        id: hlsAudioTracks[i].id,\n        active: this._hls.audioTrack === hlsAudioTracks[i].id,\n        label: hlsAudioTracks[i].name,\n        language: hlsAudioTracks[i].lang,\n        index: i\n      };\n      audioTracks.push(new AudioTrack(settings));\n    }\n    return audioTracks;\n  }\n\n  /**\n   * Parse hls video tracks into player video tracks.\n   * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n   * @returns {Array<VideoTrack>} - The parsed video tracks.\n   * @private\n   */\n  _parseVideoTracks(hlsVideoTracks: Array<Object>): Array<VideoTrack> {\n    let videoTracks = [];\n    for (let i = 0; i < hlsVideoTracks.length; i++) {\n      // Create video tracks\n      let settings = {\n        active: this._hls.startLevel === i,\n        bandwidth: hlsVideoTracks[i].bitrate,\n        width: hlsVideoTracks[i].width,\n        height: hlsVideoTracks[i].height,\n        language: '',\n        index: i\n      };\n      videoTracks.push(new VideoTrack(settings));\n    }\n    return videoTracks;\n  }\n\n  /**\n   * Parse hls text tracks into player text tracks.\n   * @param {Array<Object>} hlsTextTracks - The hls text tracks.\n   * @returns {Array<TextTrack>} - The parsed text tracks.\n   * @private\n   */\n  _parseTextTracks(hlsTextTracks: Array<Object>): Array<TextTrack> {\n    let textTracks = [];\n    for (const hlsTextTrack of hlsTextTracks) {\n      // Create text tracks\n      let settings = {\n        id: hlsTextTrack.id,\n        active: hlsTextTrack.default,\n        label: hlsTextTrack.name,\n        kind: hlsTextTrack.type.toLowerCase(),\n        language: hlsTextTrack.lang\n      };\n      textTracks.push(new TextTrack(settings));\n    }\n    return textTracks;\n  }\n\n  /**\n   * Parse a CEA 608/708 text track which not expose on hlsjs api into player text tracks.\n   * @param {Object} CEATextTrack - A video element text track.\n   * @returns {?TextTrack} - A parsed text track if the param is a CEA 608/708 caption.\n   * @private\n   */\n  _parseCEATextTrack(CEATextTrack: Object): ?TextTrack {\n    let textTrack = null;\n    if (CEATextTrack.kind === 'captions') {\n      const settings = {\n        id: CEATextTrack.id,\n        active: CEATextTrack.mode === 'showing',\n        label: CEATextTrack.label,\n        kind: CEATextTrack.kind,\n        language: CEATextTrack.language\n      };\n      textTrack = new TextTrack(settings);\n      this._nativeTextTracksMap[textTrack.index] = CEATextTrack;\n    }\n    return textTrack;\n  }\n\n  /**\n   * Select an audio track.\n   * @function selectAudioTrack\n   * @param {AudioTrack} audioTrack - the audio track to select.\n   * @returns {void}\n   * @public\n   */\n  selectAudioTrack(audioTrack: AudioTrack): void {\n    if (audioTrack instanceof AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n      this._hls.audioTrack = audioTrack.id;\n    }\n  }\n\n  /**\n   * Select a video track.\n   * @function selectVideoTrack\n   * @param {VideoTrack} videoTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectVideoTrack(videoTrack: VideoTrack): void {\n    if (videoTrack instanceof VideoTrack && (!videoTrack.active || this.isAdaptiveBitrateEnabled()) && this._hls.levels) {\n      if (this.isAdaptiveBitrateEnabled()) {\n        this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'manual'});\n      }\n      this._hls.currentLevel = videoTrack.index;\n    }\n  }\n\n  /**\n   * Select a text track.\n   * @function selectTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectTextTrack(textTrack: TextTrack): void {\n    if (textTrack instanceof TextTrack && !textTrack.active && this._hls) {\n      if (this._hls.subtitleTracks.length) {\n        this._hls.subtitleTrack = textTrack.id;\n        this._notifyTrackChanged(textTrack);\n      } else {\n        this._selectNativeTextTrack(textTrack);\n      }\n    }\n  }\n\n  /**\n   * Select a video element text track.\n   * @function _selectNativeTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @private\n   */\n  _selectNativeTextTrack(textTrack: TextTrack): void {\n    const selectedTrack = this._nativeTextTracksMap[textTrack.index];\n    if (selectedTrack) {\n      this.disableNativeTextTracks();\n      selectedTrack.mode = this._config.subtitleDisplay ? 'showing' : 'hidden';\n      this._notifyTrackChanged(textTrack);\n    }\n  }\n\n  _notifyTrackChanged(textTrack: TextTrack): void {\n    this._onTrackChanged(textTrack);\n  }\n\n  /** Hide the text track\n   * @function hideTextTrack\n   * @returns {void}\n   * @public\n   */\n  hideTextTrack(): void {\n    if (this._hls) {\n      if (this._hls.subtitleTracks.length) {\n        this._hls.subtitleTrack = -1;\n      } else {\n        this.disableNativeTextTracks();\n      }\n    }\n  }\n\n  /**\n   * Enables adaptive bitrate switching according to hls.js logic.\n   * @function enableAdaptiveBitrate\n   * @returns {void}\n   * @public\n   */\n  enableAdaptiveBitrate(): void {\n    if (!this.isAdaptiveBitrateEnabled()) {\n      this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'auto'});\n      this._hls.nextLevel = -1;\n    }\n  }\n\n  /**\n   * Checking if adaptive bitrate switching is enabled.\n   * @function isAdaptiveBitrateEnabled\n   * @returns {boolean} - Whether adaptive bitrate is enabled.\n   * @public\n   */\n  isAdaptiveBitrateEnabled(): boolean {\n    if (this._hls) {\n      return this._hls.autoLevelEnabled;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Apply ABR restriction.\n   * @function applyABRRestriction\n   * @param {PKABRRestrictionObject} restrictions - abr restrictions config\n   * @returns {void}\n   * @public\n   */\n  applyABRRestriction(restrictions: PKABRRestrictionObject): void {\n    Utils.Object.createPropertyPath(this._config, 'abr.restrictions', restrictions);\n    if (!this._hls.capLevelToPlayerSize) {\n      this._maybeApplyAbrRestrictions(restrictions);\n    }\n  }\n\n  /**\n   * Returns the details of hls level\n   * @function _getLevelDetails\n   * @returns {Object} - Level details\n   * @private\n   */\n  _getLevelDetails(): Object {\n    const level =\n      this._hls.levels[this._hls.currentLevel] ||\n      this._hls.levels[this._hls.nextLevel] ||\n      this._hls.levels[this._hls.nextAutoLevel] ||\n      this._hls.levels[this._hls.nextLoadLevel];\n    return level && level.details ? level.details : {};\n  }\n\n  /**\n   * Returns the live edge\n   * @returns {number} - live edge\n   * @private\n   */\n  _getLiveEdge(): number {\n    try {\n      let liveEdge;\n      if (this._hls.liveSyncPosition) {\n        liveEdge = this._hls.liveSyncPosition;\n      } else if (this._hls.config.liveSyncDuration) {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDuration;\n      } else {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDurationCount * this._getLevelDetails().targetduration;\n      }\n      return liveEdge > 0 ? liveEdge : this._videoElement.duration;\n    } catch (e) {\n      HlsAdapter._logger.debug('Live edge calculation failed, fall back to duration');\n      return this._videoElement.duration;\n    }\n  }\n\n  /**\n   * Seeking to live edge, calculated according hls configuration - liveSyncDuration or liveSyncDurationCount.\n   * @function seekToLiveEdge\n   * @returns {void}\n   * @public\n   */\n  seekToLiveEdge(): void {\n    try {\n      this._videoElement.currentTime = this._getLiveEdge();\n    } catch (e) {\n      return;\n    }\n  }\n\n  /**\n   * Gets the segment duration of the stream\n   * @return {number} - Segment duration in seconds\n   */\n  getSegmentDuration(): number {\n    const fragCurrent = Utils.Object.getPropertyPath(this._hls, 'streamController.fragCurrent');\n    return fragCurrent ? fragCurrent.duration : 0;\n  }\n\n  /**\n   * Gets the live duration\n   * @return {number} - live duration\n   */\n  get liveDuration(): number {\n    return this._getLiveEdge() + this.getSegmentDuration();\n  }\n\n  /**\n   * Checking if the current playback is live.\n   * @function isLive\n   * @returns {boolean} - Whether playback is live.\n   * @public\n   */\n  isLive(): boolean {\n    try {\n      return !!this._getLevelDetails().live;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Fired after manifest has been loaded.\n   * @function _onManifestLoaded\n   * @param {any} data - the data of the manifest load event\n   * @private\n   * @returns {void}\n   */\n  _onManifestLoaded(data: any): void {\n    HlsAdapter._logger.debug('The source has been loaded successfully');\n    if (!this._hls.config.autoStartLoad) {\n      this._hls.startLoad(this._startTime);\n    }\n    this._playerTracks = this._parseTracks();\n    // set current level to disable the auto selection in hls\n    if (!this._config.abr.enabled) {\n      this._hls.currentLevel = 0;\n    }\n    this._mediaAttachedPromise.then(() => {\n      this._loadPromiseHandlers?.resolve({tracks: this._playerTracks});\n      this._loadPromiseHandlers = null;\n    });\n    const {loading} = data.stats;\n    const manifestDownloadTime = loading.end - loading.start;\n    this._trigger(EventType.MANIFEST_LOADED, {miliSeconds: manifestDownloadTime});\n  }\n\n  /**\n   * apply ABR restrictions\n   * @private\n   * @param {PKABRRestrictionObject} restrictions - abt config object\n   * @returns {void}\n   */\n  _maybeApplyAbrRestrictions(restrictions: PKABRRestrictionObject): void {\n    const videoTracks = this._playerTracks.filter(track => track instanceof VideoTrack);\n    const availableTracks = filterTracksByRestriction(videoTracks, restrictions);\n    if (availableTracks.length) {\n      const minLevel = availableTracks[0];\n      const maxLevel = availableTracks.pop();\n      this._hls.config.minAutoBitrate = minLevel.bandwidth;\n      this._hls.autoLevelCapping = maxLevel.index;\n\n      const activeTrackInRange = availableTracks.some(track => track.active);\n      if (!this.isAdaptiveBitrateEnabled() && !activeTrackInRange) {\n        this.selectVideoTrack(minLevel);\n      }\n    } else {\n      HlsAdapter._logger.warn('Invalid restrictions, there are not tracks within the restriction range');\n    }\n  }\n\n  /**\n   * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n   * @function _onLevelSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onLevelSwitched(event: string, data: any): void {\n    let videoTrack = this._playerTracks.find(track => {\n      return track instanceof VideoTrack && track.index === data.level;\n    });\n    this._onTrackChanged(videoTrack);\n  }\n\n  /**\n   * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n   * @function _onAudioTrackSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onAudioTrackSwitched(event: string, data: any): void {\n    let audioTrack = this._playerTracks.find(track => {\n      return track instanceof AudioTrack && track.id === data.id;\n    });\n    this._onTrackChanged(audioTrack);\n    this._handleWaitingUponAudioTrackSwitch();\n  }\n\n  /**\n   * Trigger a playing event whenever an audio track is changed & time_update event is fired.\n   * This align Edge and IE behaviour to other browsers. When an audio track changed in IE & Edge, they trigger\n   * waiting event but not playing event.\n   * @returns {void}\n   * @private\n   */\n  _handleWaitingUponAudioTrackSwitch(): void {\n    const affectedBrowsers = ['IE', 'Edge'];\n    if (affectedBrowsers.includes(Env.browser.name)) {\n      const timeUpdateListener = () => {\n        this._trigger(EventType.PLAYING);\n      };\n      this._eventManager.listenOnce(this._videoElement, EventType.TIME_UPDATE, timeUpdateListener);\n    }\n  }\n\n  /**\n   * Creates a detailed Error Object according to the relevant error name\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {any} - the relevant error data object\n   */\n  _getErrorDataObject(data: any): any {\n    let errorDataObject = {};\n    errorDataObject.name = data.details;\n    switch (errorDataObject.name) {\n      case Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR:\n      case Hlsjs.ErrorDetails.LEVEL_LOAD_ERROR:\n      case Hlsjs.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n        errorDataObject.url = data.url;\n        errorDataObject.responseCode = data.response ? data.response.code : null;\n        break;\n      case Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      case Hlsjs.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case Hlsjs.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n        errorDataObject.url = data.url;\n        break;\n      case Hlsjs.ErrorDetails.MANIFEST_PARSING_ERROR:\n        errorDataObject.url = data.url;\n        errorDataObject.reason = data.reason;\n        break;\n      case Hlsjs.ErrorDetails.LEVEL_SWITCH_ERROR:\n        errorDataObject.level = data.level;\n        errorDataObject.reason = data.reason;\n        break;\n      case Hlsjs.ErrorDetails.FRAG_LOAD_ERROR:\n        errorDataObject.fragUrl = data.frag ? data.frag.url : null;\n        errorDataObject.responseCode = data.response ? data.response.code : null;\n        break;\n      case Hlsjs.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        errorDataObject.fragUrl = data.frag ? data.frag.url : null;\n        break;\n      case Hlsjs.ErrorDetails.FRAG_DECRYPT_ERROR:\n      case Hlsjs.ErrorDetails.FRAG_PARSING_ERROR:\n        errorDataObject.reason = data.reason;\n        break;\n      case Hlsjs.ErrorDetails.KEY_LOAD_ERROR:\n        errorDataObject.fragDecryptedDataUri = data.frag && data.frag.decryptdata ? data.frag.decryptdata.uri : null;\n        errorDataObject.responseCode = data.response ? data.response.code : null;\n        break;\n      case Hlsjs.ErrorDetails.KEY_LOAD_TIMEOUT:\n        errorDataObject.fragDecryptedDataUri = data.frag && data.frag.decryptdata ? data.frag.decryptdata.uri : null;\n        break;\n      case Hlsjs.ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n        errorDataObject.mimeType = data.mimeType;\n        errorDataObject.errorMsg = data.err ? data.err.message : null;\n        break;\n      case Hlsjs.ErrorDetails.BUFFER_STALLED_ERROR:\n        errorDataObject.buffer = data.buffer;\n        break;\n    }\n    if (this._requestFilterError || this._responseFilterError) {\n      errorDataObject.reason = data.response.text;\n    }\n    return errorDataObject;\n  }\n\n  /**\n   * Handles hls errors.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onError(data: any): void {\n    const errorType = data.type;\n    const errorName = data.details;\n    const errorFatal = data.fatal;\n    let errorDataObject = this._getErrorDataObject(data);\n    if (errorFatal) {\n      let error: typeof PKError;\n      switch (errorType) {\n        case Hlsjs.ErrorTypes.NETWORK_ERROR:\n          {\n            let code;\n            if (this._requestFilterError) {\n              code = PKError.Code.REQUEST_FILTER_ERROR;\n            } else if (this._responseFilterError) {\n              code = PKError.Code.RESPONSE_FILTER_ERROR;\n            } else {\n              code = PKError.Code.HTTP_ERROR;\n            }\n            if (\n              [Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR, Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT].includes(errorName) &&\n              !this._triedReloadWithRedirect &&\n              !this._config.forceRedirectExternalStreams &&\n              !this._requestFilterError &&\n              !this._responseFilterError\n            ) {\n              error = new PKError(PKError.Severity.RECOVERABLE, PKError.Category.NETWORK, code, errorDataObject);\n              this._reloadWithDirectManifest();\n            } else {\n              error = new PKError(PKError.Severity.CRITICAL, PKError.Category.NETWORK, code, errorDataObject);\n            }\n          }\n          break;\n        case Hlsjs.ErrorTypes.MEDIA_ERROR:\n          if (this._handleMediaError()) {\n            error = new PKError(PKError.Severity.RECOVERABLE, PKError.Category.MEDIA, PKError.Code.HLS_FATAL_MEDIA_ERROR, errorDataObject);\n          } else {\n            error = new PKError(PKError.Severity.CRITICAL, PKError.Category.MEDIA, PKError.Code.HLS_FATAL_MEDIA_ERROR, errorDataObject);\n          }\n          break;\n        default:\n          error = new PKError(PKError.Severity.CRITICAL, PKError.Category.PLAYER, PKError.Code.HLS_FATAL_MEDIA_ERROR, errorDataObject);\n          break;\n      }\n      this._trigger(EventType.ERROR, error);\n      if (error && error.severity === PKError.Severity.CRITICAL) {\n        if (this._loadPromiseHandlers) {\n          this._loadPromiseHandlers?.reject(error);\n          this._loadPromiseHandlers = null;\n          this._loadPromise = null;\n        }\n        this.destroy();\n      }\n    } else {\n      const {category, code}: ErrorDetailsType =\n        this._requestFilterError || this._responseFilterError\n          ? {\n              category: PKError.Category.NETWORK,\n              code: this._requestFilterError ? PKError.Code.REQUEST_FILTER_ERROR : PKError.Code.RESPONSE_FILTER_ERROR\n            }\n          : HlsJsErrorMap[errorName] || {category: 0, code: 0};\n      HlsAdapter._logger.warn(new PKError(PKError.Severity.RECOVERABLE, category, code, errorDataObject));\n    }\n    this._requestFilterError = false;\n    this._responseFilterError = false;\n  }\n\n  /**\n   * Tries to handle media errors via hls.js error handlers\n   * @returns {boolean} - if media error is handled or not\n   * @private\n   */\n  _handleMediaError(): boolean {\n    const now: number = performance.now();\n    let recover = true;\n    if (this._checkTimeDeltaHasPassed(now, this._recoverDecodingErrorDate, this._config.recoverDecodingErrorDelay)) {\n      this._eventManager.listen(this._videoElement, EventType.LOADED_METADATA, this._onRecoveredCallback);\n      this._recoverDecodingError();\n    } else {\n      if (this._checkTimeDeltaHasPassed(now, this._recoverSwapAudioCodecDate, this._config.recoverSwapAudioCodecDelay)) {\n        this._eventManager.listen(this._videoElement, EventType.LOADED_METADATA, this._onRecoveredCallback);\n        this._recoverSwapAudioCodec();\n      } else {\n        recover = false;\n        HlsAdapter._logger.error('cannot recover, last media error recovery failed');\n      }\n    }\n    return recover;\n  }\n\n  /**\n   * trigger mediarecovered event if metadata is loaded (means the recovery succeeded)\n   * @returns {void}\n   * @private\n   */\n  _onRecovered(): void {\n    this._trigger(EventType.MEDIA_RECOVERED);\n    this._videoElement.removeEventListener(EventType.LOADED_METADATA, this._onRecoveredCallback);\n  }\n\n  /**\n   * Check if time ahs passed a certain delta\n   * @param {number} now - current time\n   * @param {number} then - previous time\n   * @param {number} delay - time delta in ms\n   * @returns {boolean} - if time delta has\n   * @private\n   */\n  _checkTimeDeltaHasPassed(now: number, then: number, delay: number): boolean {\n    return !then || now - then > delay;\n  }\n\n  /**\n   * handle recover from decoding error\n   * @returns {void}\n   * @private\n   */\n  _recoverDecodingError(): void {\n    this._recoverDecodingErrorDate = performance.now();\n    HlsAdapter._logger.warn('try to recover media Error');\n    this._hls.recoverMediaError();\n  }\n\n  /**\n   * handle recover from decoding error by swaping audio codec\n   * @returns {void}\n   * @private\n   */\n  _recoverSwapAudioCodec(): void {\n    this._recoverSwapAudioCodecDate = performance.now();\n    HlsAdapter._logger.warn('try to swap Audio Codec and recover media Error');\n    this._hls.swapAudioCodec();\n    this._hls.recoverMediaError();\n  }\n\n  /**\n   * Removes hls.js bindings.\n   * @returns {void}\n   * @private\n   */\n  _removeBindings(): void {\n    for (const [event, callback] of Object.entries(this._adapterEventsBindings)) {\n      this._hls.off(event, callback);\n    }\n    this._videoElement.textTracks.onaddtrack = null;\n    this._onRecoveredCallback = null;\n    if (this._eventManager) {\n      this._eventManager.removeAll();\n    }\n  }\n\n  /**\n   * Get the start time of DVR window in live playback in seconds.\n   * @returns {Number} - start time of DVR window.\n   * @public\n   */\n  getStartTimeOfDvrWindow(): number {\n    if (this.isLive()) {\n      try {\n        const nextLoadLevel = this._hls.levels[this._hls.nextLoadLevel],\n          details = nextLoadLevel.details,\n          fragments = details.fragments,\n          fragLength = fragments.length,\n          start = fragments[0].start + fragments[0].duration,\n          end = fragments[fragLength - 1].start + fragments[fragLength - 1].duration,\n          maxLatency =\n            this._hls.config.liveMaxLatencyDuration !== undefined\n              ? this._hls.config.liveMaxLatencyDuration\n              : this._hls.config.liveMaxLatencyDurationCount * details.targetduration,\n          minPosToSeek = Math.max(start - this._hls.config.maxFragLookUpTolerance, end - maxLatency);\n        return minPosToSeek;\n      } catch (e) {\n        HlsAdapter._logger.debug('Unable obtain the start of DVR window');\n        return 0;\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  /**\n   * called when a level is loaded\n   * @private\n   * @param {any} e - the event object\n   * @param {any} data - the event data\n   * @returns {void}\n   */\n  _onLevelLoaded = (e: any, data: any) => {\n    if (this.isLive()) {\n      const {\n        details: {endSN}\n      } = data;\n      if (this._lastLoadedFragSN === endSN) {\n        this._sameFragSNLoadedCount++;\n        HlsAdapter._logger.debug(`Same frag SN. Count is: ${this._sameFragSNLoadedCount}, Max is: ${this._config.network.maxStaleLevelReloads}`);\n        if (this._sameFragSNLoadedCount >= this._config.network.maxStaleLevelReloads) {\n          HlsAdapter._logger.error(`Same frag loading reached max count`);\n          const error = new PKError(PKError.Severity.CRITICAL, PKError.Category.NETWORK, PKError.Code.LIVE_MANIFEST_REFRESH_ERROR, {\n            fragSN: endSN\n          });\n          this._trigger(EventType.ERROR, error);\n          return this.destroy();\n        }\n        HlsAdapter._logger.debug(`Last frag SN is: ${endSN}`);\n      } else {\n        this._sameFragSNLoadedCount = 0;\n      }\n      this._lastLoadedFragSN = endSN;\n    }\n  };\n\n  /**\n   * called when a fragment is loaded\n   * @private\n   * @param {any} data - the event data of the loaded fragment\n   * @returns {void}\n   */\n  _onFragLoaded(data: any): void {\n    if (Utils.Object.hasPropertyPath(data, 'frag.stats.loading')) {\n      const {stats} = data.frag;\n      const fragmentDownloadTime = stats.loading.end - stats.loading.start;\n      this._trigger(EventType.FRAG_LOADED, {\n        miliSeconds: fragmentDownloadTime,\n        bytes: stats.loaded,\n        url: data.frag.url\n      });\n    }\n  }\n\n  /**\n   * returns value the player targets the buffer\n   * @returns {number} buffer target length in seconds\n   */\n  get targetBuffer(): number {\n    let targetBufferVal = NaN;\n    if (!this._hls) return NaN;\n    //distance from playback duration is the relevant buffer\n    if (this.isLive()) {\n      targetBufferVal = this._getLiveTargetBuffer() - (this._videoElement.currentTime - this._getLiveEdge());\n    } else {\n      // consideration of the end of the playback in the target buffer calc\n      targetBufferVal = this._videoElement.duration - this._videoElement.currentTime;\n    }\n    targetBufferVal = Math.min(targetBufferVal, this._hls.config.maxMaxBufferLength + this._getLevelDetails().targetduration);\n    return targetBufferVal;\n  }\n\n  _getLiveTargetBuffer() {\n    // if defined in the configuration object, liveSyncDuration will take precedence over the default liveSyncDurationCount\n    if (this._hls.config.liveSyncDuration) {\n      return this._hls.config.liveSyncDuration;\n    } else {\n      return this._hls.config.liveSyncDurationCount * this._getLevelDetails().targetduration;\n    }\n  }\n}\n","// @flow\nimport {registerMediaSourceAdapter} from '@playkit-js/playkit-js';\nimport HlsAdapter from './hls-adapter';\n\ndeclare var __VERSION__: string;\ndeclare var __NAME__: string;\n\nconst VERSION = __VERSION__;\nconst NAME = __NAME__;\n\nexport default HlsAdapter;\nexport {VERSION, NAME};\n\n// Register hls adapter to the media source adapter provider.\nif (HlsAdapter.isSupported()) {\n  registerMediaSourceAdapter(HlsAdapter);\n}\n"],"sourceRoot":""}