{"version":3,"sources":["./hls/webpack/universalModuleDefinition","./hls/playkit-hls.js","./hls/webpack/bootstrap d4cf1e6c8c1f38b1ab63","./hls/external {\"commonjs\":\"@playkit-js/playkit-js\",\"commonjs2\":\"@playkit-js/playkit-js\",\"amd\":\"playkit-js\",\"root\":[\"playkit\",\"core\"]}","./hls/external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}","./hls/./index.js","./hls/./hls-adapter.js","./hls/./default-config.json","./hls/./errors.js","./hls/./jsonp-ploader.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","NAME","VERSION","undefined","_playkitJs","_hlsAdapter","_hlsAdapter2","obj","default","isSupported","registerMediaSourceAdapter","_interopRequireDefault","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_hls","_hls2","_defaultConfig","_defaultConfig2","_errors","_jsonpPloader","_jsonpPloader2","HlsAdapter","_BaseMediaSourceAdapt","videoElement","source","config","_logger","debug","version","_this","_triedReloadWithRedirect","_startTime","_config","Utils","mergeDeep","forceRedirectExternalStreams","hlsConfig","_capabilities","fpsControl","subtitleDisplay","_addBindings","adapterConfig","copyDeep","hasPropertyPath","options","sources","redirectExternalStreamsHandler","redirectExternalStreamsTimeout","getPropertyPath","startPosition","playback","startTime","fpsDroppedFramesInterval","abr","fpsDroppedMonitoringThreshold","capLevelOnFPSDrop","enableCEA708Captions","captionsTextTrack1Label","captionsTextTrack1LanguageCode","captionsTextTrack2Label","captionsTextTrack2LanguageCode","enabled","capLevelToPlayerSize","defaultBandwidthEstimate","abrEwmaDefaultEstimate","restrictions","minBitrate","minAutoBitrate","maxBitrate","Infinity","html5","hls","mimeType","canHlsPlayType","_hlsMimeTypes","includes","toLowerCase","toString","warn","isHlsSupported","_this2","on","Events","ERROR","e","data","_onError","MANIFEST_LOADED","_onManifestLoaded","bind","LEVEL_SWITCHED","_onLevelSwitched","AUDIO_TRACK_SWITCHED","_onAudioTrackSwitched","FPS_DROP","_onFpsDrop","_onRecoveredCallback","_onRecovered","_onAddTrack","_videoElement","addEventListener","textTracks","onaddtrack","_trigger","EventType","event","subtitleTracks","CEATextTrack","_parseCEATextTrack","track","_playerTracks","push","TRACKS_CHANGED","tracks","error","code","MEDIA_ERR_DECODE","message","_handleMediaError","_this3","_loadPromise","Promise","resolve","_resolveLoad","_loadInternal","_sourceObj","url","loadSource","attachMedia","ABR_MODE_CHANGED","mode","isAdaptiveBitrateEnabled","_reset","removeEventListener","LOADED_METADATA","_this4","then","_removeBindings","clearTimeout","_resolveLoadTimeout","detachMedia","destroy","audioTracks","_parseAudioTracks","videoTracks","_parseVideoTracks","levels","_parseTextTracks","concat","hlsAudioTracks","settings","id","active","audioTrack","label","language","lang","index","AudioTrack","hlsVideoTracks","startLevel","bandwidth","bitrate","width","height","VideoTrack","hlsTextTracks","kind","type","TextTrack","textTrack","filter","videoTrack","currentLevel","subtitleTrack","_notifyTrackChanged","_selectNativeTextTrack","selectedTrack","Array","from","find","_disableNativeTextTracks","_onTrackChanged","forEach","nextLevel","autoLevelEnabled","level","nextAutoLevel","nextLoadLevel","details","liveEdge","liveSyncPosition","liveSyncDuration","duration","liveSyncDurationCount","_getLevelDetails","targetduration","currentTime","_getLiveEdge","live","autoStartLoad","startLoad","_parseTracks","_maybeHandleInitialTracksWorkaround","_this5","hasDefaultTextTrack","some","numberOfEventsToWait","handler","_maybeApplyAbrRestrictions","once","SUBTITLE_FRAG_PROCESSED","AUDIO_TRACK_SWITCHING","setTimeout","maxLevel","findIndex","autoLevelCapping","_handleWaitingUponAudioTrackSwitch","_this6","Env","browser","timeUpdateListener","PLAYING","TIME_UPDATE","errorType","errorDetails","fatal","ErrorTypes","NETWORK_ERROR","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","Error","Severity","CRITICAL","Category","NETWORK","Code","HTTP_ERROR","_reloadWithDirectManifest","MEDIA_ERROR","RECOVERABLE","MEDIA","HLS_FATAL_MEDIA_ERROR","PLAYER","severity","_ref","HlsJsErrorMap","category","now","performance","recover","_checkTimeDeltaHasPassed","_recoverDecodingErrorDate","recoverDecodingErrorDelay","_recoverDecodingError","_recoverSwapAudioCodecDate","recoverSwapAudioCodecDelay","_recoverSwapAudioCodec","MEDIA_RECOVERED","delay","recoverMediaError","swapAudioCodec","off","_removeRecoveredCallbackListener","isLive","fragments","fragLength","start","end","maxLatency","liveMaxLatencyDuration","liveMaxLatencyDurationCount","Math","max","maxFragLookUpTolerance","BaseMediaSourceAdapter","getLogger","fragLoadingMaxRetry","maxMaxBufferLength","_defineProperty","_HlsJsErrorMap","MANIFEST","TIMEOUT","MANIFEST_PARSING_ERROR","HLSJS_CANNOT_PARSE","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","LEVEL_SWITCH_ERROR","BITRATE_SWITCH_ISSUE","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","FRAG_PARSING_ERROR","HLS_FRAG_PARSING_ERROR","BUFFER_APPEND_ERROR","HLS_BUFFER_APPEND_ISSUE","BUFFER_APPENDING_ERROR","HLS_BUFFER_APPENDING_ISSUE","BUFFER_STALLED_ERROR","HLS_BUFFER_STALLED_ERROR","pLoader","_Hlsjs$DefaultConfig$","loadOrig","load","callback","context","callbacks","Http","jsonp","timeout","uri","catch","DefaultConfig","loader"],"mappings":"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","file":"playkit-hls.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"hls.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hls\"] = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse\n\t\troot[\"playkit\"] = root[\"playkit\"] || {}, root[\"playkit\"][\"hls\"] = factory(root[\"playkit\"][\"core\"], root[\"Hls\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"playkit-js\", \"hls.js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hls\"] = factory(require(\"@playkit-js/playkit-js\"), require(\"hls.js\"));\n\telse\n\t\troot[\"playkit\"] = root[\"playkit\"] || {}, root[\"playkit\"][\"hls\"] = factory(root[\"playkit\"][\"core\"], root[\"Hls\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAME = exports.VERSION = undefined;\n\nvar _playkitJs = __webpack_require__(0);\n\nvar _hlsAdapter = __webpack_require__(3);\n\nvar _hlsAdapter2 = _interopRequireDefault(_hlsAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _hlsAdapter2.default;\nexports.VERSION = \"1.10.2\";\nexports.NAME = \"@playkit-js/playkit-js-hls\";\n\n// Register hls adapter to the media source adapter provider.\n\nif (_hlsAdapter2.default.isSupported()) {\n  (0, _playkitJs.registerMediaSourceAdapter)(_hlsAdapter2.default);\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _defaultConfig = __webpack_require__(4);\n\nvar _defaultConfig2 = _interopRequireDefault(_defaultConfig);\n\nvar _errors = __webpack_require__(5);\n\nvar _playkitJs = __webpack_require__(0);\n\nvar _jsonpPloader = __webpack_require__(6);\n\nvar _jsonpPloader2 = _interopRequireDefault(_jsonpPloader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nvar HlsAdapter = function (_BaseMediaSourceAdapt) {\n  _inherits(HlsAdapter, _BaseMediaSourceAdapt);\n\n  _createClass(HlsAdapter, null, [{\n    key: 'createAdapter',\n\n\n    /**\n     * Factory method to create media source adapter.\n     * @function createAdapter\n     * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n     * @param {PKMediaSourceObject} source - The source Object.\n     * @param {Object} config - The player configuration.\n     * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n     * @static\n     */\n\n    /**\n     * Reference to _onVideoError function\n     * @member {?Function} - _onVideoErrorCallback\n     * @type {?Function}\n     * @private\n     */\n\n\n    /**\n     * Reference to _onRecoveredCallback function\n     * @member {?Function} - _onRecoveredCallback\n     * @type {?Function}\n     * @private\n     */\n\n\n    /**\n     * indicate if external redirect was performed\n     * @type {boolean}\n     * @private\n     */\n\n    /**\n     * The hls player instance.\n     * @member {any} _hls\n     * @private\n     */\n\n\n    /**\n     * last recover date from decoding error\n     * @type {number}\n     * @private\n     */\n\n\n    /**\n     * last recover date from audio swap codec operation\n     * @type {number}\n     * @private\n     */\n\n    /**\n     * The adapter logger.\n     * @member {any} _logger\n     * @static\n     * @private\n     */\n    value: function createAdapter(videoElement, source, config) {\n      var adapterConfig = _playkitJs.Utils.Object.copyDeep(_defaultConfig2.default);\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'sources.options')) {\n        var options = config.sources.options;\n        adapterConfig.forceRedirectExternalStreams = options.forceRedirectExternalStreams;\n        adapterConfig.redirectExternalStreamsHandler = options.redirectExternalStreamsHandler;\n        adapterConfig.redirectExternalStreamsTimeout = options.redirectExternalStreamsTimeout;\n        _jsonpPloader2.default.redirectExternalStreamsHandler = adapterConfig.redirectExternalStreamsHandler;\n        _jsonpPloader2.default.redirectExternalStreamsTimeout = adapterConfig.redirectExternalStreamsTimeout;\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'playback.startTime')) {\n        var startTime = _playkitJs.Utils.Object.getPropertyPath(config, 'playback.startTime');\n        if (startTime > -1) {\n          adapterConfig.hlsConfig.startPosition = config.playback.startTime;\n        }\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'playback.useNativeTextTrack')) {\n        adapterConfig.subtitleDisplay = _playkitJs.Utils.Object.getPropertyPath(config, 'playback.useNativeTextTrack');\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedFramesInterval')) {\n        adapterConfig.hlsConfig.fpsDroppedFramesInterval = config.abr.fpsDroppedFramesInterval;\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedMonitoringThreshold')) {\n        adapterConfig.hlsConfig.fpsDroppedMonitoringThreshold = config.abr.fpsDroppedMonitoringThreshold;\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'abr.capLevelOnFPSDrop')) {\n        adapterConfig.hlsConfig.capLevelOnFPSDrop = config.abr.capLevelOnFPSDrop;\n      }\n      adapterConfig.hlsConfig.enableCEA708Captions = config.playback.enableCEA708Captions;\n      adapterConfig.hlsConfig.captionsTextTrack1Label = config.playback.captionsTextTrack1Label;\n      adapterConfig.hlsConfig.captionsTextTrack1LanguageCode = config.playback.captionsTextTrack1LanguageCode;\n      adapterConfig.hlsConfig.captionsTextTrack2Label = config.playback.captionsTextTrack2Label;\n      adapterConfig.hlsConfig.captionsTextTrack2LanguageCode = config.playback.captionsTextTrack2LanguageCode;\n\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'abr')) {\n        var abr = config.abr;\n        if (typeof abr.enabled === 'boolean') {\n          adapterConfig.abr.enabled = abr.enabled;\n        }\n        if (typeof abr.capLevelToPlayerSize === 'boolean') {\n          adapterConfig.hlsConfig.capLevelToPlayerSize = abr.capLevelToPlayerSize;\n        }\n        if (abr.defaultBandwidthEstimate) {\n          adapterConfig.hlsConfig.abrEwmaDefaultEstimate = abr.defaultBandwidthEstimate;\n        }\n        if (abr.restrictions.minBitrate > 0) {\n          adapterConfig.hlsConfig.minAutoBitrate = abr.restrictions.minBitrate;\n        }\n        if (abr.restrictions.maxBitrate < Infinity) {\n          //You can either set capping by size or bitrate, if bitrate is set then disable size capping\n          adapterConfig.hlsConfig.capLevelToPlayerSize = false;\n          adapterConfig.abr.restrictions = abr.restrictions;\n        }\n      }\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n        _playkitJs.Utils.Object.mergeDeep(adapterConfig.hlsConfig, config.playback.options.html5.hls);\n      }\n      return new this(videoElement, source, adapterConfig);\n    }\n\n    /**\n     * Checks if hls adapter can play a given mime type.\n     * @function canPlayType\n     * @param {string} mimeType - The mime type to check.\n     * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n     * @static\n     */\n\n    /**\n     * stream start time in seconds\n     * @type {?number}\n     * @private\n     */\n\n\n    /**\n     * The load promise\n     * @member {Promise<Object>} - _loadPromise\n     * @type {Promise<Object>}\n     * @private\n     */\n\n\n    /**\n     * Reference to the player tracks.\n     * @member {Array<Track>} - _playerTracks\n     * @type {Array<Track>}\n     * @private\n     */\n\n    /**\n     * The supported mime types by the hls adapter.\n     * @member {Array<string>} _hlsMimeType\n     * @static\n     * @private\n     */\n\n    /**\n     * The id of the adapter.\n     * @member {string} id\n     * @static\n     * @private\n     */\n\n  }, {\n    key: 'canPlayType',\n    value: function canPlayType(mimeType) {\n      var canHlsPlayType = typeof mimeType === 'string' ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n      HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n      return canHlsPlayType;\n    }\n\n    /**\n     * Checks if hls adapter can play a given drm data.\n     * For hls.js it always returns false.\n     * @returns {boolean} - Whether the hls adapter can play a specific drm data.\n     * @static\n     */\n\n  }, {\n    key: 'canPlayDrm',\n    value: function canPlayDrm() {\n      HlsAdapter._logger.warn('canPlayDrm result is false');\n      return false;\n    }\n\n    /**\n     * Checks if the hls adapter is supported.\n     * @function isSupported\n     * @returns {boolean} - Whether hls is supported.\n     * @static\n     */\n\n  }, {\n    key: 'isSupported',\n    value: function isSupported() {\n      var isHlsSupported = _hls2.default.isSupported();\n      HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n      return isHlsSupported;\n    }\n\n    /**\n     * @constructor\n     * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n     * @param {PKMediaSourceObject} source - The source object\n     * @param {Object} config - The media source adapter configuration\n     */\n\n  }]);\n\n  function HlsAdapter(videoElement, source, config) {\n    _classCallCheck(this, HlsAdapter);\n\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + _hls2.default.version);\n\n    var _this = _possibleConstructorReturn(this, (HlsAdapter.__proto__ || Object.getPrototypeOf(HlsAdapter)).call(this, videoElement, source, config));\n\n    _this._triedReloadWithRedirect = false;\n    _this._startTime = 0;\n\n    _this._config = _playkitJs.Utils.Object.mergeDeep({}, _defaultConfig2.default, _this._config);\n    if (_this._config.forceRedirectExternalStreams) {\n      _this._config.hlsConfig['pLoader'] = _jsonpPloader2.default;\n    }\n    _this._hls = new _hls2.default(_this._config.hlsConfig);\n    _this._capabilities.fpsControl = true;\n    _this._hls.subtitleDisplay = _this._config.subtitleDisplay;\n    _this._addBindings();\n    return _this;\n  }\n\n  /**\n   * Adds the required bindings locally and with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n\n\n  _createClass(HlsAdapter, [{\n    key: '_addBindings',\n    value: function _addBindings() {\n      var _this2 = this;\n\n      this._hls.on(_hls2.default.Events.ERROR, function (e, data) {\n        return _this2._onError(data);\n      });\n      this._hls.on(_hls2.default.Events.MANIFEST_LOADED, this._onManifestLoaded.bind(this));\n      this._hls.on(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n      this._hls.on(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n      this._hls.on(_hls2.default.Events.FPS_DROP, function (e, data) {\n        return _this2._onFpsDrop(data);\n      });\n      this._onRecoveredCallback = function () {\n        return _this2._onRecovered();\n      };\n      this._onAddTrack = this._onAddTrack.bind(this);\n      this._videoElement.addEventListener('addtrack', this._onAddTrack);\n      this._videoElement.textTracks.onaddtrack = this._onAddTrack;\n    }\n  }, {\n    key: '_onFpsDrop',\n    value: function _onFpsDrop(data) {\n      this._trigger(_playkitJs.EventType.FPS_DROP, data);\n    }\n  }, {\n    key: '_onAddTrack',\n    value: function _onAddTrack(event) {\n      if (!this._hls.subtitleTracks.length) {\n        // parse CEA 608/708 captions that not exposed on hls.subtitleTracks API\n        var CEATextTrack = this._parseCEATextTrack(event.track);\n        if (CEATextTrack) {\n          HlsAdapter._logger.debug('A CEA 608/708 caption has found', CEATextTrack);\n          this._playerTracks.push(CEATextTrack);\n          this._trigger(_playkitJs.EventType.TRACKS_CHANGED, { tracks: this._playerTracks });\n        }\n      }\n    }\n\n    /**\n     * video error event handler.\n     * @param {MediaError} error - the media error\n     * @public\n     * @returns {boolean} if hls-adapter will try to recover\n     */\n\n  }, {\n    key: 'handleMediaError',\n    value: function handleMediaError(error) {\n      if (error.code === error.MEDIA_ERR_DECODE) {\n        HlsAdapter._logger.debug('The video playback was aborted due to a corruption problem or because the video used features your browser did not support.', error.message);\n        return this._handleMediaError();\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Load the video source\n     * @function load\n     * @param {number} startTime - Optional time to start the video from.\n     * @returns {Promise<Object>} - The loaded data\n     * @override\n     */\n\n  }, {\n    key: 'load',\n    value: function load(startTime) {\n      var _this3 = this;\n\n      if (!this._loadPromise) {\n        this._startTime = startTime;\n        this._loadPromise = new Promise(function (resolve) {\n          _this3._resolveLoad = resolve;\n          _this3._loadInternal();\n        });\n      }\n      return this._loadPromise;\n    }\n\n    /**\n     * Load the video source\n     * @function load\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_loadInternal',\n    value: function _loadInternal() {\n      if (this._sourceObj && this._sourceObj.url) {\n        this._hls.loadSource(this._sourceObj.url);\n        this._hls.attachMedia(this._videoElement);\n        this._trigger(_playkitJs.EventType.ABR_MODE_CHANGED, { mode: this.isAdaptiveBitrateEnabled() ? 'auto' : 'manual' });\n      }\n    }\n\n    /**\n     * Load the video source with installed playlist loader\n     * @function _reloadWithDirectManifest\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_reloadWithDirectManifest',\n    value: function _reloadWithDirectManifest() {\n      // Mark that we tried once to redirect\n      this._triedReloadWithRedirect = true;\n      // reset hls.js\n      this._reset();\n      // re-init hls.js with the external redirect playlist loader\n      this._config.hlsConfig['pLoader'] = _jsonpPloader2.default;\n      this._hls = new _hls2.default(this._config.hlsConfig);\n      this._addBindings();\n      this._loadInternal();\n    }\n\n    /**\n     * Remove the loadedmetadata listener, when recovering from media error.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_removeRecoveredCallbackListener',\n    value: function _removeRecoveredCallbackListener() {\n      if (this._onRecoveredCallback) {\n        this._videoElement.removeEventListener(_playkitJs.EventType.LOADED_METADATA, this._onRecoveredCallback);\n        this._onRecoveredCallback = null;\n      }\n    }\n\n    /**\n     * Destroys the hls adapter.\n     * @function destroy\n     * @override\n     * @returns {Promise<*>} - The destroy promise.\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var _this4 = this;\n\n      return _get(HlsAdapter.prototype.__proto__ || Object.getPrototypeOf(HlsAdapter.prototype), 'destroy', this).call(this).then(function () {\n        HlsAdapter._logger.debug('destroy');\n        _this4._loadPromise = null;\n        _this4._playerTracks = [];\n        _this4._reset();\n      });\n    }\n\n    /**\n     * reset hls.js instance and its bindings\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      this._removeBindings();\n      clearTimeout(this._resolveLoadTimeout);\n      this._hls.detachMedia();\n      this._hls.destroy();\n    }\n\n    /**\n     * Parse the hls tracks into player tracks.\n     * @returns {Array<Track>} - The parsed tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTracks',\n    value: function _parseTracks() {\n      var audioTracks = this._parseAudioTracks(this._hls.audioTracks || []);\n      var videoTracks = this._parseVideoTracks(this._hls.levels || []);\n      var textTracks = this._parseTextTracks(this._hls.subtitleTracks || []);\n      return audioTracks.concat(videoTracks).concat(textTracks);\n    }\n\n    /**\n     * Parse hls audio tracks into player audio tracks.\n     * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n     * @returns {Array<AudioTrack>} - The parsed audio tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseAudioTracks',\n    value: function _parseAudioTracks(hlsAudioTracks) {\n      var audioTracks = [];\n      for (var i = 0; i < hlsAudioTracks.length; i++) {\n        // Create audio tracks\n        var settings = {\n          id: hlsAudioTracks[i].id,\n          active: this._hls.audioTrack === hlsAudioTracks[i].id,\n          label: hlsAudioTracks[i].name,\n          language: hlsAudioTracks[i].lang,\n          index: i\n        };\n        audioTracks.push(new _playkitJs.AudioTrack(settings));\n      }\n      return audioTracks;\n    }\n\n    /**\n     * Parse hls video tracks into player video tracks.\n     * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n     * @returns {Array<VideoTrack>} - The parsed video tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseVideoTracks',\n    value: function _parseVideoTracks(hlsVideoTracks) {\n      var videoTracks = [];\n      for (var i = 0; i < hlsVideoTracks.length; i++) {\n        // Create video tracks\n        var settings = {\n          active: this._hls.startLevel === i,\n          bandwidth: hlsVideoTracks[i].bitrate,\n          width: hlsVideoTracks[i].width,\n          height: hlsVideoTracks[i].height,\n          language: '',\n          index: i\n        };\n        videoTracks.push(new _playkitJs.VideoTrack(settings));\n      }\n      return videoTracks;\n    }\n\n    /**\n     * Parse hls text tracks into player text tracks.\n     * @param {Array<Object>} hlsTextTracks - The hls text tracks.\n     * @returns {Array<TextTrack>} - The parsed text tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTextTracks',\n    value: function _parseTextTracks(hlsTextTracks) {\n      var textTracks = [];\n      for (var i = 0; i < hlsTextTracks.length; i++) {\n        // Create text tracks\n        var settings = {\n          id: hlsTextTracks[i].id,\n          active: hlsTextTracks[i].default,\n          label: hlsTextTracks[i].name,\n          kind: hlsTextTracks[i].type.toLowerCase(),\n          language: hlsTextTracks[i].lang,\n          index: i\n        };\n        textTracks.push(new _playkitJs.TextTrack(settings));\n      }\n      return textTracks;\n    }\n\n    /**\n     * Parse a CEA 608/708 text track which not expose on hlsjs api into player text tracks.\n     * @param {Object} CEATextTrack - A video element text track.\n     * @returns {?TextTrack} - A parsed text track if the param is a CEA 608/708 caption.\n     * @private\n     */\n\n  }, {\n    key: '_parseCEATextTrack',\n    value: function _parseCEATextTrack(CEATextTrack) {\n      var textTrack = null;\n      if (CEATextTrack.kind === 'captions') {\n        var settings = {\n          id: CEATextTrack.id,\n          active: CEATextTrack.mode === 'showing',\n          label: CEATextTrack.label,\n          kind: CEATextTrack.kind,\n          language: CEATextTrack.language,\n          index: this._playerTracks.filter(function (track) {\n            return track instanceof _playkitJs.TextTrack;\n          }).length\n        };\n        textTrack = new _playkitJs.TextTrack(settings);\n      }\n      return textTrack;\n    }\n\n    /**\n     * Select an audio track.\n     * @function selectAudioTrack\n     * @param {AudioTrack} audioTrack - the audio track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectAudioTrack',\n    value: function selectAudioTrack(audioTrack) {\n      if (audioTrack instanceof _playkitJs.AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n        this._hls.audioTrack = audioTrack.id;\n      }\n    }\n\n    /**\n     * Select a video track.\n     * @function selectVideoTrack\n     * @param {VideoTrack} videoTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectVideoTrack',\n    value: function selectVideoTrack(videoTrack) {\n      if (videoTrack instanceof _playkitJs.VideoTrack && (!videoTrack.active || this.isAdaptiveBitrateEnabled()) && this._hls.levels) {\n        if (this.isAdaptiveBitrateEnabled()) {\n          this._trigger(_playkitJs.EventType.ABR_MODE_CHANGED, { mode: 'manual' });\n        }\n        this._hls.currentLevel = videoTrack.index;\n      }\n    }\n\n    /**\n     * Select a text track.\n     * @function selectTextTrack\n     * @param {TextTrack} textTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectTextTrack',\n    value: function selectTextTrack(textTrack) {\n      if (textTrack instanceof _playkitJs.TextTrack && !textTrack.active) {\n        if (this._hls.subtitleTracks.length) {\n          this._hls.subtitleTrack = textTrack.id;\n          this._notifyTrackChanged(textTrack);\n        } else {\n          this._selectNativeTextTrack(textTrack);\n        }\n      }\n    }\n\n    /**\n     * Select a video element text track.\n     * @function _selectNativeTextTrack\n     * @param {TextTrack} textTrack - the track to select.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_selectNativeTextTrack',\n    value: function _selectNativeTextTrack(textTrack) {\n      var selectedTrack = Array.from(this._videoElement.textTracks).find(function (track) {\n        return track.language === textTrack.language;\n      });\n      if (selectedTrack) {\n        this._disableNativeTextTracks();\n        selectedTrack.mode = this._config.subtitleDisplay ? 'showing' : 'hidden';\n        this._notifyTrackChanged(textTrack);\n      }\n    }\n  }, {\n    key: '_notifyTrackChanged',\n    value: function _notifyTrackChanged(textTrack) {\n      HlsAdapter._logger.debug('Text track changed', textTrack);\n      this._onTrackChanged(textTrack);\n    }\n\n    /**\n     * Disables all the video element text tracks.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_disableNativeTextTracks',\n    value: function _disableNativeTextTracks() {\n      Array.from(this._videoElement.textTracks).forEach(function (track) {\n        track.mode = 'disabled';\n      });\n    }\n\n    /** Hide the text track\n     * @function hideTextTrack\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'hideTextTrack',\n    value: function hideTextTrack() {\n      if (this._hls.subtitleTracks.length) {\n        this._hls.subtitleTrack = -1;\n      } else {\n        this._disableNativeTextTracks();\n      }\n    }\n\n    /**\n     * Enables adaptive bitrate switching according to hls.js logic.\n     * @function enableAdaptiveBitrate\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'enableAdaptiveBitrate',\n    value: function enableAdaptiveBitrate() {\n      if (!this.isAdaptiveBitrateEnabled()) {\n        this._trigger(_playkitJs.EventType.ABR_MODE_CHANGED, { mode: 'auto' });\n        this._hls.nextLevel = -1;\n      }\n    }\n\n    /**\n     * Checking if adaptive bitrate switching is enabled.\n     * @function isAdaptiveBitrateEnabled\n     * @returns {boolean} - Whether adaptive bitrate is enabled.\n     * @public\n     */\n\n  }, {\n    key: 'isAdaptiveBitrateEnabled',\n    value: function isAdaptiveBitrateEnabled() {\n      return this._hls.autoLevelEnabled;\n    }\n\n    /**\n     * Returns the details of hls level\n     * @function _getLevelDetails\n     * @returns {Object} - Level details\n     * @private\n     */\n\n  }, {\n    key: '_getLevelDetails',\n    value: function _getLevelDetails() {\n      var level = this._hls.levels[this._hls.currentLevel] || this._hls.levels[this._hls.nextLevel] || this._hls.levels[this._hls.nextAutoLevel] || this._hls.levels[this._hls.nextLoadLevel];\n      return level && level.details ? level.details : {};\n    }\n\n    /**\n     * Returns the live edge\n     * @returns {number} - live edge\n     * @private\n     */\n\n  }, {\n    key: '_getLiveEdge',\n    value: function _getLiveEdge() {\n      try {\n        var liveEdge = void 0;\n        if (this._hls.liveSyncPosition) {\n          liveEdge = this._hls.liveSyncPosition;\n        } else if (this._hls.config.liveSyncDuration) {\n          liveEdge = this._videoElement.duration - this._hls.config.liveSyncDuration;\n        } else {\n          liveEdge = this._videoElement.duration - this._hls.config.liveSyncDurationCount * this._getLevelDetails().targetduration;\n        }\n        return liveEdge > 0 ? liveEdge : this._videoElement.duration;\n      } catch (e) {\n        HlsAdapter._logger.debug('Live edge calculation failed, fall back to duration');\n        return this._videoElement.duration;\n      }\n    }\n\n    /**\n     * Seeking to live edge, calculated according hls configuration - liveSyncDuration or liveSyncDurationCount.\n     * @function seekToLiveEdge\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'seekToLiveEdge',\n    value: function seekToLiveEdge() {\n      try {\n        this._videoElement.currentTime = this._getLiveEdge();\n      } catch (e) {\n        return;\n      }\n    }\n\n    /**\n     * Checking if the current playback is live.\n     * @function isLive\n     * @returns {boolean} - Whether playback is live.\n     * @public\n     */\n\n  }, {\n    key: 'isLive',\n    value: function isLive() {\n      try {\n        return !!this._getLevelDetails().live;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    /**\n     * Fired after manifest has been loaded.\n     * @function _onManifestLoaded\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onManifestLoaded',\n    value: function _onManifestLoaded() {\n      HlsAdapter._logger.debug('The source has been loaded successfully');\n      if (!this._hls.config.autoStartLoad) {\n        this._hls.startLoad(this._startTime);\n      }\n      this._playerTracks = this._parseTracks();\n      //TODO: workaround for various hls.js issues with the initial track selection logic.\n      //TODO: once https://github.com/video-dev/hls.js/issues/1948 is solved and we move to next hls.js version we need to reomve this if clause\n      if (!this._maybeHandleInitialTracksWorkaround()) {\n        this._resolveLoad({ tracks: this._playerTracks });\n      }\n    }\n  }, {\n    key: '_maybeHandleInitialTracksWorkaround',\n    value: function _maybeHandleInitialTracksWorkaround() {\n      var _this5 = this;\n\n      var hasDefaultTextTrack = this._hls.subtitleTracks.some(function (track) {\n        return track.default;\n      });\n      if (this._hls.audioTracks.length > 1 || hasDefaultTextTrack) {\n        var numberOfEventsToWait = 0;\n        var handler = function handler() {\n          if (--numberOfEventsToWait == 0) {\n            _this5._maybeApplyAbrRestrictions();\n            _this5._resolveLoad({ tracks: _this5._playerTracks });\n          }\n        };\n        if (hasDefaultTextTrack) {\n          numberOfEventsToWait++;\n          this._hls.once(_hls2.default.Events.SUBTITLE_FRAG_PROCESSED, handler);\n        }\n        if (this._hls.audioTracks.length > 1) {\n          numberOfEventsToWait++;\n          this._hls.once(_hls2.default.Events.AUDIO_TRACK_SWITCHING, handler);\n        }\n        this._resolveLoadTimeout = setTimeout(function () {\n          _this5._resolveLoad({ tracks: _this5._playerTracks });\n        }, 1000);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * apply ABR restrictions\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_maybeApplyAbrRestrictions',\n    value: function _maybeApplyAbrRestrictions() {\n      if (this._config.abr.enabled) {\n        if (this._config.abr.restrictions) {\n          var restrictions = this._config.abr.restrictions;\n          if (restrictions.maxBitrate) {\n            var minBitrate = restrictions.minBitrate ? restrictions.minBitrate : 0;\n            if (restrictions.maxBitrate > minBitrate) {\n              //Get the first level that is above our bitrate restriction\n              //If the corresponding level is not in the edges (level 0 or last level) then get the previous level index\n              //which has a bitrate value which is lower then the max bitrate restriction\n              var maxLevel = this._hls.levels.findIndex(function (level) {\n                return level.bitrate > restrictions.maxBitrate;\n              });\n              if (maxLevel > 0) {\n                maxLevel = maxLevel - 1;\n              }\n              this._hls.autoLevelCapping = maxLevel;\n            } else {\n              HlsAdapter._logger.warn('Invalid maxBitrate restriction, maxBitrate must be greater than minBitrate', minBitrate, restrictions.maxBitrate);\n            }\n          }\n        }\n      } else {\n        this._hls.currentLevel = 0;\n      }\n    }\n\n    /**\n     * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n     * @function _onLevelSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onLevelSwitched',\n    value: function _onLevelSwitched(event, data) {\n      var videoTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.VideoTrack && track.index === data.level;\n      });\n      HlsAdapter._logger.debug('Video track changed', videoTrack);\n      this._onTrackChanged(videoTrack);\n    }\n\n    /**\n     * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n     * @function _onAudioTrackSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onAudioTrackSwitched',\n    value: function _onAudioTrackSwitched(event, data) {\n      var audioTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.AudioTrack && track.id === data.id;\n      });\n      HlsAdapter._logger.debug('Audio track changed', audioTrack);\n      this._onTrackChanged(audioTrack);\n      this._handleWaitingUponAudioTrackSwitch();\n    }\n\n    /**\n     * Trigger a playing event whenever an audio track is changed & time_update event is fired.\n     * This align Edge and IE behaviour to other browsers. When an audio track changed in IE & Edge, they trigger\n     * waiting event but not playing event.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_handleWaitingUponAudioTrackSwitch',\n    value: function _handleWaitingUponAudioTrackSwitch() {\n      var _this6 = this;\n\n      var affectedBrowsers = ['IE', 'Edge'];\n      if (affectedBrowsers.includes(_playkitJs.Env.browser.name)) {\n        var timeUpdateListener = function timeUpdateListener() {\n          _this6._trigger(_playkitJs.EventType.PLAYING);\n          _this6._videoElement.removeEventListener(_playkitJs.EventType.TIME_UPDATE, timeUpdateListener);\n        };\n        this._videoElement.addEventListener(_playkitJs.EventType.TIME_UPDATE, timeUpdateListener);\n      }\n    }\n\n    /**\n     * Handles hls errors.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(data) {\n      var errorType = data.type;\n      var errorDetails = data.details;\n      var errorFatal = data.fatal;\n      if (errorFatal) {\n        var error = void 0;\n        switch (errorType) {\n          case _hls2.default.ErrorTypes.NETWORK_ERROR:\n            if ([_hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR, _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT].includes(errorDetails) && !this._triedReloadWithRedirect && !this._config.forceRedirectExternalStreams) {\n              this._reloadWithDirectManifest();\n            } else {\n              error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.NETWORK, _playkitJs.Error.Code.HTTP_ERROR, errorDetails);\n            }\n            break;\n          case _hls2.default.ErrorTypes.MEDIA_ERROR:\n            if (this._handleMediaError()) {\n              error = new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, _playkitJs.Error.Category.MEDIA, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            } else {\n              error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.MEDIA, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            }\n            break;\n          default:\n            error = new _playkitJs.Error(_playkitJs.Error.Severity.CRITICAL, _playkitJs.Error.Category.PLAYER, _playkitJs.Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n            break;\n        }\n        this._trigger(_playkitJs.EventType.ERROR, error);\n        if (error && error.severity === _playkitJs.Error.Severity.CRITICAL) {\n          this.destroy();\n        }\n      } else {\n        var _ref = _errors.HlsJsErrorMap[errorDetails] || { category: 0, code: 0 },\n            category = _ref.category,\n            code = _ref.code;\n\n        HlsAdapter._logger.warn(new _playkitJs.Error(_playkitJs.Error.Severity.RECOVERABLE, category, code, errorDetails));\n      }\n    }\n\n    /**\n     * Tries to handle media errors via hls.js error handlers\n     * @returns {boolean} - if media error is handled or not\n     * @private\n     */\n\n  }, {\n    key: '_handleMediaError',\n    value: function _handleMediaError() {\n      var now = performance.now();\n      var recover = true;\n      if (this._checkTimeDeltaHasPassed(now, this._recoverDecodingErrorDate, this._config.recoverDecodingErrorDelay)) {\n        this._videoElement.addEventListener(_playkitJs.EventType.LOADED_METADATA, this._onRecoveredCallback);\n        this._recoverDecodingError();\n      } else {\n        if (this._checkTimeDeltaHasPassed(now, this._recoverSwapAudioCodecDate, this._config.recoverSwapAudioCodecDelay)) {\n          this._videoElement.addEventListener(_playkitJs.EventType.LOADED_METADATA, this._onRecoveredCallback);\n          this._recoverSwapAudioCodec();\n        } else {\n          recover = false;\n          HlsAdapter._logger.error('cannot recover, last media error recovery failed');\n        }\n      }\n      return recover;\n    }\n\n    /**\n     * trigger mediarecovered event if metadata is loaded (means the recovery succeeded)\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_onRecovered',\n    value: function _onRecovered() {\n      this._trigger(_playkitJs.EventType.MEDIA_RECOVERED);\n      this._videoElement.removeEventListener(_playkitJs.EventType.LOADED_METADATA, this._onRecoveredCallback);\n    }\n\n    /**\n     * Check if time ahs passed a certain delta\n     * @param {number} now - current time\n     * @param {number} then - previous time\n     * @param {number} delay - time delta in ms\n     * @returns {boolean} - if time delta has\n     * @private\n     */\n\n  }, {\n    key: '_checkTimeDeltaHasPassed',\n    value: function _checkTimeDeltaHasPassed(now, then, delay) {\n      return !then || now - then > delay;\n    }\n\n    /**\n     * handle recover from decoding error\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_recoverDecodingError',\n    value: function _recoverDecodingError() {\n      this._recoverDecodingErrorDate = performance.now();\n      HlsAdapter._logger.warn('try to recover media Error');\n      this._hls.recoverMediaError();\n    }\n\n    /**\n     * handle recover from decoding error by swaping audio codec\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_recoverSwapAudioCodec',\n    value: function _recoverSwapAudioCodec() {\n      this._recoverSwapAudioCodecDate = performance.now();\n      HlsAdapter._logger.warn('try to swap Audio Codec and recover media Error');\n      this._hls.swapAudioCodec();\n      this._hls.recoverMediaError();\n    }\n\n    /**\n     * Removes hls.js bindings.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_removeBindings',\n    value: function _removeBindings() {\n      this._hls.off(_hls2.default.Events.ERROR, this._onError);\n      this._hls.off(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n      this._hls.off(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n      this._hls.off(_hls2.default.Events.MANIFEST_LOADED, this._onManifestLoaded);\n      this._hls.off(_hls2.default.Events.FPS_DROP, this._onFpsDrop);\n      this._videoElement.textTracks.onaddtrack = null;\n      this._videoElement.removeEventListener('addtrack', this._onAddTrack);\n      this._removeRecoveredCallbackListener();\n    }\n\n    /**\n     * Get the start time of DVR window in live playback in seconds.\n     * @returns {Number} - start time of DVR window.\n     * @public\n     */\n\n  }, {\n    key: 'getStartTimeOfDvrWindow',\n    value: function getStartTimeOfDvrWindow() {\n      if (this.isLive()) {\n        try {\n          var nextLoadLevel = this._hls.levels[this._hls.nextLoadLevel],\n              details = nextLoadLevel.details,\n              fragments = details.fragments,\n              fragLength = fragments.length,\n              start = fragments[0].start + fragments[0].duration,\n              end = fragments[fragLength - 1].start + fragments[fragLength - 1].duration,\n              maxLatency = this._hls.config.liveMaxLatencyDuration !== undefined ? this._hls.config.liveMaxLatencyDuration : this._hls.config.liveMaxLatencyDurationCount * details.targetduration,\n              minPosToSeek = Math.max(start - this._hls.config.maxFragLookUpTolerance, end - maxLatency);\n          return minPosToSeek;\n        } catch (e) {\n          HlsAdapter._logger.debug('Unable obtain the start of DVR window');\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    }\n  }]);\n\n  return HlsAdapter;\n}(_playkitJs.BaseMediaSourceAdapter);\n\nHlsAdapter.id = 'HlsAdapter';\nHlsAdapter._logger = _playkitJs.BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\nHlsAdapter._hlsMimeTypes = ['application/x-mpegurl', 'application/vnd.apple.mpegurl', 'audio/mpegurl', 'audio/x-mpegurl', 'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\nexports.default = HlsAdapter;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n\t\"recoverDecodingErrorDelay\": 3000,\n\t\"recoverSwapAudioCodecDelay\": 3000,\n\t\"abr\": {\n\t\t\"enabled\": true,\n\t\t\"restrictions\": {}\n\t},\n\t\"hlsConfig\": {\n\t\t\"fragLoadingMaxRetry\": 4,\n\t\t\"maxMaxBufferLength\": 60\n\t}\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HlsJsErrorMap = undefined;\n\nvar _HlsJsErrorMap;\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _playkitJs = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar HlsJsErrorMap = (_HlsJsErrorMap = {}, _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR, {\n  category: _playkitJs.Error.Category.MANIFEST,\n  code: _playkitJs.Error.Code.HLSJS_CANNOT_PARSE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.LEVEL_SWITCH_ERROR, {\n  category: _playkitJs.Error.Category.PLAYER,\n  code: _playkitJs.Error.Code.BITRATE_SWITCH_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOAD_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOOP_LOADING_ERROR, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.HTTP_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_LOAD_TIMEOUT, {\n  category: _playkitJs.Error.Category.NETWORK,\n  code: _playkitJs.Error.Code.TIMEOUT\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.FRAG_PARSING_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_FRAG_PARSING_ERROR\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_APPEND_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_APPEND_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_APPENDING_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_APPENDING_ISSUE\n}), _defineProperty(_HlsJsErrorMap, _hls2.default.ErrorDetails.BUFFER_STALLED_ERROR, {\n  category: _playkitJs.Error.Category.MEDIA,\n  code: _playkitJs.Error.Code.HLS_BUFFER_STALLED_ERROR\n}), _HlsJsErrorMap);\n\nexports.HlsJsErrorMap = HlsJsErrorMap;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _playkitJs = __webpack_require__(0);\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * A plugin override for the loader function in hls.js.\n * It checks if it should use jsonp for the manifest first, else - the regular\n * loader is called.\n */\nvar pLoader = function (_Hlsjs$DefaultConfig$) {\n  _inherits(pLoader, _Hlsjs$DefaultConfig$);\n\n  /**\n   * @constructor\n   * @param {Object} config - hlsjs config object. it also contains the jsonp callback function\n   */\n  function pLoader(config) {\n    _classCallCheck(this, pLoader);\n\n    var _this = _possibleConstructorReturn(this, (pLoader.__proto__ || Object.getPrototypeOf(pLoader)).call(this, config));\n\n    var loadOrig = _this.load.bind(_this);\n    var callback = pLoader.redirectExternalStreamsHandler;\n    _this.load = function (context, config, callbacks) {\n      var url = context.url;\n      if (context.type === 'manifest') {\n        _playkitJs.Utils.Http.jsonp(url, callback, {\n          timeout: pLoader.redirectExternalStreamsTimeout\n        }).then(function (uri) {\n          context.url = uri;\n          loadOrig(context, config, callbacks);\n        }).catch(function () {\n          return loadOrig(context, config, callbacks);\n        });\n      } else {\n        loadOrig(context, config, callbacks);\n      }\n    };\n    return _this;\n  }\n  /**\n   * redirect external stream handler function\n   * @param {string} uri - the original uri\n   * @returns {string} uri - the redirected URI\n   * @static\n   */\n\n\n  return pLoader;\n}(_hls2.default.DefaultConfig.loader);\n\npLoader.redirectExternalStreamsHandler = function (uri) {\n  return uri;\n};\n\nexports.default = pLoader;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// playkit-hls.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d4cf1e6c8c1f38b1ab63","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"@playkit-js/playkit-js\",\"commonjs2\":\"@playkit-js/playkit-js\",\"amd\":\"playkit-js\",\"root\":[\"playkit\",\"core\"]}\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}\n// module id = 1\n// module chunks = 0","// @flow\nimport {registerMediaSourceAdapter} from '@playkit-js/playkit-js';\nimport HlsAdapter from './hls-adapter';\n\ndeclare var __VERSION__: string;\ndeclare var __NAME__: string;\n\nexport default HlsAdapter;\nexport {__VERSION__ as VERSION, __NAME__ as NAME};\n\n// Register hls adapter to the media source adapter provider.\nif (HlsAdapter.isSupported()) {\n  registerMediaSourceAdapter(HlsAdapter);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","//@flow\nimport Hlsjs from 'hls.js';\nimport DefaultConfig from './default-config';\nimport {type ErrorDetailsType, HlsJsErrorMap} from './errors';\nimport {AudioTrack, BaseMediaSourceAdapter, Env, Error, EventType, TextTrack, Track, Utils, VideoTrack} from '@playkit-js/playkit-js';\nimport pLoader from './jsonp-ploader';\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nexport default class HlsAdapter extends BaseMediaSourceAdapter {\n  /**\n   * The id of the adapter.\n   * @member {string} id\n   * @static\n   * @private\n   */\n  static id: string = 'HlsAdapter';\n  /**\n   * The adapter logger.\n   * @member {any} _logger\n   * @static\n   * @private\n   */\n  static _logger = BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\n  /**\n   * The supported mime types by the hls adapter.\n   * @member {Array<string>} _hlsMimeType\n   * @static\n   * @private\n   */\n  static _hlsMimeTypes: Array<string> = [\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    'audio/mpegurl',\n    'audio/x-mpegurl',\n    'video/x-mpegurl',\n    'video/mpegurl',\n    'application/mpegurl'\n  ];\n  /**\n   * The hls player instance.\n   * @member {any} _hls\n   * @private\n   */\n  _hls: any;\n\n  /**\n   * last recover date from decoding error\n   * @type {number}\n   * @private\n   */\n  _recoverDecodingErrorDate: number;\n\n  /**\n   * last recover date from audio swap codec operation\n   * @type {number}\n   * @private\n   */\n  _recoverSwapAudioCodecDate: number;\n\n  /**\n   * indicate if external redirect was performed\n   * @type {boolean}\n   * @private\n   */\n  _triedReloadWithRedirect: boolean = false;\n\n  /**\n   * The load promise\n   * @member {Promise<Object>} - _loadPromise\n   * @type {Promise<Object>}\n   * @private\n   */\n  _loadPromise: ?Promise<Object>;\n\n  /**\n   * Reference to the player tracks.\n   * @member {Array<Track>} - _playerTracks\n   * @type {Array<Track>}\n   * @private\n   */\n  _playerTracks: Array<Track>;\n  /**\n   * stream start time in seconds\n   * @type {?number}\n   * @private\n   */\n  _startTime: ?number = 0;\n  /**\n   * Reference to _onVideoError function\n   * @member {?Function} - _onVideoErrorCallback\n   * @type {?Function}\n   * @private\n   */\n  _onVideoErrorCallback: ?Function;\n\n  /**\n   * Reference to _onRecoveredCallback function\n   * @member {?Function} - _onRecoveredCallback\n   * @type {?Function}\n   * @private\n   */\n  _onRecoveredCallback: ?Function;\n  _onAddTrack: Function;\n  _resolveLoadTimeout: number;\n\n  /**\n   * Factory method to create media source adapter.\n   * @function createAdapter\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n   * @param {PKMediaSourceObject} source - The source Object.\n   * @param {Object} config - The player configuration.\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n   * @static\n   */\n  static createAdapter(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object): IMediaSourceAdapter {\n    let adapterConfig: Object = Utils.Object.copyDeep(DefaultConfig);\n    if (Utils.Object.hasPropertyPath(config, 'sources.options')) {\n      const options = config.sources.options;\n      adapterConfig.forceRedirectExternalStreams = options.forceRedirectExternalStreams;\n      adapterConfig.redirectExternalStreamsHandler = options.redirectExternalStreamsHandler;\n      adapterConfig.redirectExternalStreamsTimeout = options.redirectExternalStreamsTimeout;\n      pLoader.redirectExternalStreamsHandler = adapterConfig.redirectExternalStreamsHandler;\n      pLoader.redirectExternalStreamsTimeout = adapterConfig.redirectExternalStreamsTimeout;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'playback.startTime')) {\n      const startTime = Utils.Object.getPropertyPath(config, 'playback.startTime');\n      if (startTime > -1) {\n        adapterConfig.hlsConfig.startPosition = config.playback.startTime;\n      }\n    }\n    if (Utils.Object.hasPropertyPath(config, 'playback.useNativeTextTrack')) {\n      adapterConfig.subtitleDisplay = Utils.Object.getPropertyPath(config, 'playback.useNativeTextTrack');\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedFramesInterval')) {\n      adapterConfig.hlsConfig.fpsDroppedFramesInterval = config.abr.fpsDroppedFramesInterval;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.fpsDroppedMonitoringThreshold')) {\n      adapterConfig.hlsConfig.fpsDroppedMonitoringThreshold = config.abr.fpsDroppedMonitoringThreshold;\n    }\n    if (Utils.Object.hasPropertyPath(config, 'abr.capLevelOnFPSDrop')) {\n      adapterConfig.hlsConfig.capLevelOnFPSDrop = config.abr.capLevelOnFPSDrop;\n    }\n    adapterConfig.hlsConfig.enableCEA708Captions = config.playback.enableCEA708Captions;\n    adapterConfig.hlsConfig.captionsTextTrack1Label = config.playback.captionsTextTrack1Label;\n    adapterConfig.hlsConfig.captionsTextTrack1LanguageCode = config.playback.captionsTextTrack1LanguageCode;\n    adapterConfig.hlsConfig.captionsTextTrack2Label = config.playback.captionsTextTrack2Label;\n    adapterConfig.hlsConfig.captionsTextTrack2LanguageCode = config.playback.captionsTextTrack2LanguageCode;\n\n    if (Utils.Object.hasPropertyPath(config, 'abr')) {\n      const abr = config.abr;\n      if (typeof abr.enabled === 'boolean') {\n        adapterConfig.abr.enabled = abr.enabled;\n      }\n      if (typeof abr.capLevelToPlayerSize === 'boolean') {\n        adapterConfig.hlsConfig.capLevelToPlayerSize = abr.capLevelToPlayerSize;\n      }\n      if (abr.defaultBandwidthEstimate) {\n        adapterConfig.hlsConfig.abrEwmaDefaultEstimate = abr.defaultBandwidthEstimate;\n      }\n      if (abr.restrictions.minBitrate > 0) {\n        adapterConfig.hlsConfig.minAutoBitrate = abr.restrictions.minBitrate;\n      }\n      if (abr.restrictions.maxBitrate < Infinity) {\n        //You can either set capping by size or bitrate, if bitrate is set then disable size capping\n        adapterConfig.hlsConfig.capLevelToPlayerSize = false;\n        adapterConfig.abr.restrictions = abr.restrictions;\n      }\n    }\n    if (Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n      Utils.Object.mergeDeep(adapterConfig.hlsConfig, config.playback.options.html5.hls);\n    }\n    return new this(videoElement, source, adapterConfig);\n  }\n\n  /**\n   * Checks if hls adapter can play a given mime type.\n   * @function canPlayType\n   * @param {string} mimeType - The mime type to check.\n   * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n   * @static\n   */\n  static canPlayType(mimeType: string): boolean {\n    let canHlsPlayType = typeof mimeType === 'string' ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n    HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n    return canHlsPlayType;\n  }\n\n  /**\n   * Checks if hls adapter can play a given drm data.\n   * For hls.js it always returns false.\n   * @returns {boolean} - Whether the hls adapter can play a specific drm data.\n   * @static\n   */\n  static canPlayDrm(): boolean {\n    HlsAdapter._logger.warn('canPlayDrm result is false');\n    return false;\n  }\n\n  /**\n   * Checks if the hls adapter is supported.\n   * @function isSupported\n   * @returns {boolean} - Whether hls is supported.\n   * @static\n   */\n  static isSupported(): boolean {\n    let isHlsSupported = Hlsjs.isSupported();\n    HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n    return isHlsSupported;\n  }\n\n  /**\n   * @constructor\n   * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n   * @param {PKMediaSourceObject} source - The source object\n   * @param {Object} config - The media source adapter configuration\n   */\n  constructor(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object) {\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + Hlsjs.version);\n    super(videoElement, source, config);\n    this._config = Utils.Object.mergeDeep({}, DefaultConfig, this._config);\n    if (this._config.forceRedirectExternalStreams) {\n      this._config.hlsConfig['pLoader'] = pLoader;\n    }\n    this._hls = new Hlsjs(this._config.hlsConfig);\n    this._capabilities.fpsControl = true;\n    this._hls.subtitleDisplay = this._config.subtitleDisplay;\n    this._addBindings();\n  }\n\n  /**\n   * Adds the required bindings locally and with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n  _addBindings(): void {\n    this._hls.on(Hlsjs.Events.ERROR, (e, data) => this._onError(data));\n    this._hls.on(Hlsjs.Events.MANIFEST_LOADED, this._onManifestLoaded.bind(this));\n    this._hls.on(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n    this._hls.on(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n    this._hls.on(Hlsjs.Events.FPS_DROP, (e, data) => this._onFpsDrop(data));\n    this._onRecoveredCallback = () => this._onRecovered();\n    this._onAddTrack = this._onAddTrack.bind(this);\n    this._videoElement.addEventListener('addtrack', this._onAddTrack);\n    this._videoElement.textTracks.onaddtrack = this._onAddTrack;\n  }\n\n  _onFpsDrop(data: Object): void {\n    this._trigger(EventType.FPS_DROP, data);\n  }\n\n  _onAddTrack(event: any) {\n    if (!this._hls.subtitleTracks.length) {\n      // parse CEA 608/708 captions that not exposed on hls.subtitleTracks API\n      const CEATextTrack = this._parseCEATextTrack(event.track);\n      if (CEATextTrack) {\n        HlsAdapter._logger.debug('A CEA 608/708 caption has found', CEATextTrack);\n        this._playerTracks.push(CEATextTrack);\n        this._trigger(EventType.TRACKS_CHANGED, {tracks: this._playerTracks});\n      }\n    }\n  }\n\n  /**\n   * video error event handler.\n   * @param {MediaError} error - the media error\n   * @public\n   * @returns {boolean} if hls-adapter will try to recover\n   */\n  handleMediaError(error: MediaError): boolean {\n    if (error.code === error.MEDIA_ERR_DECODE) {\n      HlsAdapter._logger.debug(\n        'The video playback was aborted due to a corruption problem or because the video used features your browser did not support.',\n        error.message\n      );\n      return this._handleMediaError();\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @param {number} startTime - Optional time to start the video from.\n   * @returns {Promise<Object>} - The loaded data\n   * @override\n   */\n  load(startTime: ?number): Promise<Object> {\n    if (!this._loadPromise) {\n      this._startTime = startTime;\n      this._loadPromise = new Promise(resolve => {\n        this._resolveLoad = resolve;\n        this._loadInternal();\n      });\n    }\n    return this._loadPromise;\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @returns {void}\n   * @private\n   */\n  _loadInternal() {\n    if (this._sourceObj && this._sourceObj.url) {\n      this._hls.loadSource(this._sourceObj.url);\n      this._hls.attachMedia(this._videoElement);\n      this._trigger(EventType.ABR_MODE_CHANGED, {mode: this.isAdaptiveBitrateEnabled() ? 'auto' : 'manual'});\n    }\n  }\n\n  /**\n   * Load the video source with installed playlist loader\n   * @function _reloadWithDirectManifest\n   * @returns {void}\n   * @private\n   */\n  _reloadWithDirectManifest() {\n    // Mark that we tried once to redirect\n    this._triedReloadWithRedirect = true;\n    // reset hls.js\n    this._reset();\n    // re-init hls.js with the external redirect playlist loader\n    this._config.hlsConfig['pLoader'] = pLoader;\n    this._hls = new Hlsjs(this._config.hlsConfig);\n    this._addBindings();\n    this._loadInternal();\n  }\n\n  /**\n   * Remove the loadedmetadata listener, when recovering from media error.\n   * @private\n   * @returns {void}\n   */\n  _removeRecoveredCallbackListener(): void {\n    if (this._onRecoveredCallback) {\n      this._videoElement.removeEventListener(EventType.LOADED_METADATA, this._onRecoveredCallback);\n      this._onRecoveredCallback = null;\n    }\n  }\n\n  /**\n   * Destroys the hls adapter.\n   * @function destroy\n   * @override\n   * @returns {Promise<*>} - The destroy promise.\n   */\n  destroy(): Promise<*> {\n    return super.destroy().then(() => {\n      HlsAdapter._logger.debug('destroy');\n      this._loadPromise = null;\n      this._playerTracks = [];\n      this._reset();\n    });\n  }\n\n  /**\n   * reset hls.js instance and its bindings\n   * @private\n   * @returns {void}\n   */\n  _reset(): void {\n    this._removeBindings();\n    clearTimeout(this._resolveLoadTimeout);\n    this._hls.detachMedia();\n    this._hls.destroy();\n  }\n\n  /**\n   * Parse the hls tracks into player tracks.\n   * @returns {Array<Track>} - The parsed tracks.\n   * @private\n   */\n  _parseTracks(): Array<Track> {\n    const audioTracks = this._parseAudioTracks(this._hls.audioTracks || []);\n    const videoTracks = this._parseVideoTracks(this._hls.levels || []);\n    const textTracks = this._parseTextTracks(this._hls.subtitleTracks || []);\n    return audioTracks.concat(videoTracks).concat(textTracks);\n  }\n\n  /**\n   * Parse hls audio tracks into player audio tracks.\n   * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n   * @returns {Array<AudioTrack>} - The parsed audio tracks.\n   * @private\n   */\n  _parseAudioTracks(hlsAudioTracks: Array<Object>): Array<AudioTrack> {\n    let audioTracks = [];\n    for (let i = 0; i < hlsAudioTracks.length; i++) {\n      // Create audio tracks\n      let settings = {\n        id: hlsAudioTracks[i].id,\n        active: this._hls.audioTrack === hlsAudioTracks[i].id,\n        label: hlsAudioTracks[i].name,\n        language: hlsAudioTracks[i].lang,\n        index: i\n      };\n      audioTracks.push(new AudioTrack(settings));\n    }\n    return audioTracks;\n  }\n\n  /**\n   * Parse hls video tracks into player video tracks.\n   * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n   * @returns {Array<VideoTrack>} - The parsed video tracks.\n   * @private\n   */\n  _parseVideoTracks(hlsVideoTracks: Array<Object>): Array<VideoTrack> {\n    let videoTracks = [];\n    for (let i = 0; i < hlsVideoTracks.length; i++) {\n      // Create video tracks\n      let settings = {\n        active: this._hls.startLevel === i,\n        bandwidth: hlsVideoTracks[i].bitrate,\n        width: hlsVideoTracks[i].width,\n        height: hlsVideoTracks[i].height,\n        language: '',\n        index: i\n      };\n      videoTracks.push(new VideoTrack(settings));\n    }\n    return videoTracks;\n  }\n\n  /**\n   * Parse hls text tracks into player text tracks.\n   * @param {Array<Object>} hlsTextTracks - The hls text tracks.\n   * @returns {Array<TextTrack>} - The parsed text tracks.\n   * @private\n   */\n  _parseTextTracks(hlsTextTracks: Array<Object>): Array<TextTrack> {\n    let textTracks = [];\n    for (let i = 0; i < hlsTextTracks.length; i++) {\n      // Create text tracks\n      let settings = {\n        id: hlsTextTracks[i].id,\n        active: hlsTextTracks[i].default,\n        label: hlsTextTracks[i].name,\n        kind: hlsTextTracks[i].type.toLowerCase(),\n        language: hlsTextTracks[i].lang,\n        index: i\n      };\n      textTracks.push(new TextTrack(settings));\n    }\n    return textTracks;\n  }\n\n  /**\n   * Parse a CEA 608/708 text track which not expose on hlsjs api into player text tracks.\n   * @param {Object} CEATextTrack - A video element text track.\n   * @returns {?TextTrack} - A parsed text track if the param is a CEA 608/708 caption.\n   * @private\n   */\n  _parseCEATextTrack(CEATextTrack: Object): ?TextTrack {\n    let textTrack = null;\n    if (CEATextTrack.kind === 'captions') {\n      const settings = {\n        id: CEATextTrack.id,\n        active: CEATextTrack.mode === 'showing',\n        label: CEATextTrack.label,\n        kind: CEATextTrack.kind,\n        language: CEATextTrack.language,\n        index: this._playerTracks.filter(track => track instanceof TextTrack).length\n      };\n      textTrack = new TextTrack(settings);\n    }\n    return textTrack;\n  }\n\n  /**\n   * Select an audio track.\n   * @function selectAudioTrack\n   * @param {AudioTrack} audioTrack - the audio track to select.\n   * @returns {void}\n   * @public\n   */\n  selectAudioTrack(audioTrack: AudioTrack): void {\n    if (audioTrack instanceof AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n      this._hls.audioTrack = audioTrack.id;\n    }\n  }\n\n  /**\n   * Select a video track.\n   * @function selectVideoTrack\n   * @param {VideoTrack} videoTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectVideoTrack(videoTrack: VideoTrack): void {\n    if (videoTrack instanceof VideoTrack && (!videoTrack.active || this.isAdaptiveBitrateEnabled()) && this._hls.levels) {\n      if (this.isAdaptiveBitrateEnabled()) {\n        this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'manual'});\n      }\n      this._hls.currentLevel = videoTrack.index;\n    }\n  }\n\n  /**\n   * Select a text track.\n   * @function selectTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectTextTrack(textTrack: TextTrack): void {\n    if (textTrack instanceof TextTrack && !textTrack.active) {\n      if (this._hls.subtitleTracks.length) {\n        this._hls.subtitleTrack = textTrack.id;\n        this._notifyTrackChanged(textTrack);\n      } else {\n        this._selectNativeTextTrack(textTrack);\n      }\n    }\n  }\n\n  /**\n   * Select a video element text track.\n   * @function _selectNativeTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @private\n   */\n  _selectNativeTextTrack(textTrack: TextTrack): void {\n    const selectedTrack = Array.from(this._videoElement.textTracks).find(track => track.language === textTrack.language);\n    if (selectedTrack) {\n      this._disableNativeTextTracks();\n      selectedTrack.mode = this._config.subtitleDisplay ? 'showing' : 'hidden';\n      this._notifyTrackChanged(textTrack);\n    }\n  }\n\n  _notifyTrackChanged(textTrack: TextTrack): void {\n    HlsAdapter._logger.debug('Text track changed', textTrack);\n    this._onTrackChanged(textTrack);\n  }\n\n  /**\n   * Disables all the video element text tracks.\n   * @private\n   * @returns {void}\n   */\n  _disableNativeTextTracks(): void {\n    Array.from(this._videoElement.textTracks).forEach(track => {\n      track.mode = 'disabled';\n    });\n  }\n\n  /** Hide the text track\n   * @function hideTextTrack\n   * @returns {void}\n   * @public\n   */\n  hideTextTrack(): void {\n    if (this._hls.subtitleTracks.length) {\n      this._hls.subtitleTrack = -1;\n    } else {\n      this._disableNativeTextTracks();\n    }\n  }\n\n  /**\n   * Enables adaptive bitrate switching according to hls.js logic.\n   * @function enableAdaptiveBitrate\n   * @returns {void}\n   * @public\n   */\n  enableAdaptiveBitrate(): void {\n    if (!this.isAdaptiveBitrateEnabled()) {\n      this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'auto'});\n      this._hls.nextLevel = -1;\n    }\n  }\n\n  /**\n   * Checking if adaptive bitrate switching is enabled.\n   * @function isAdaptiveBitrateEnabled\n   * @returns {boolean} - Whether adaptive bitrate is enabled.\n   * @public\n   */\n  isAdaptiveBitrateEnabled(): boolean {\n    return this._hls.autoLevelEnabled;\n  }\n\n  /**\n   * Returns the details of hls level\n   * @function _getLevelDetails\n   * @returns {Object} - Level details\n   * @private\n   */\n  _getLevelDetails(): Object {\n    const level =\n      this._hls.levels[this._hls.currentLevel] ||\n      this._hls.levels[this._hls.nextLevel] ||\n      this._hls.levels[this._hls.nextAutoLevel] ||\n      this._hls.levels[this._hls.nextLoadLevel];\n    return level && level.details ? level.details : {};\n  }\n\n  /**\n   * Returns the live edge\n   * @returns {number} - live edge\n   * @private\n   */\n  _getLiveEdge(): number {\n    try {\n      let liveEdge;\n      if (this._hls.liveSyncPosition) {\n        liveEdge = this._hls.liveSyncPosition;\n      } else if (this._hls.config.liveSyncDuration) {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDuration;\n      } else {\n        liveEdge = this._videoElement.duration - this._hls.config.liveSyncDurationCount * this._getLevelDetails().targetduration;\n      }\n      return liveEdge > 0 ? liveEdge : this._videoElement.duration;\n    } catch (e) {\n      HlsAdapter._logger.debug('Live edge calculation failed, fall back to duration');\n      return this._videoElement.duration;\n    }\n  }\n\n  /**\n   * Seeking to live edge, calculated according hls configuration - liveSyncDuration or liveSyncDurationCount.\n   * @function seekToLiveEdge\n   * @returns {void}\n   * @public\n   */\n  seekToLiveEdge(): void {\n    try {\n      this._videoElement.currentTime = this._getLiveEdge();\n    } catch (e) {\n      return;\n    }\n  }\n\n  /**\n   * Checking if the current playback is live.\n   * @function isLive\n   * @returns {boolean} - Whether playback is live.\n   * @public\n   */\n  isLive(): boolean {\n    try {\n      return !!this._getLevelDetails().live;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Fired after manifest has been loaded.\n   * @function _onManifestLoaded\n   * @private\n   * @returns {void}\n   */\n  _onManifestLoaded(): void {\n    HlsAdapter._logger.debug('The source has been loaded successfully');\n    if (!this._hls.config.autoStartLoad) {\n      this._hls.startLoad(this._startTime);\n    }\n    this._playerTracks = this._parseTracks();\n    //TODO: workaround for various hls.js issues with the initial track selection logic.\n    //TODO: once https://github.com/video-dev/hls.js/issues/1948 is solved and we move to next hls.js version we need to reomve this if clause\n    if (!this._maybeHandleInitialTracksWorkaround()) {\n      this._resolveLoad({tracks: this._playerTracks});\n    }\n  }\n\n  _maybeHandleInitialTracksWorkaround(): boolean {\n    const hasDefaultTextTrack = this._hls.subtitleTracks.some(track => track.default);\n    if (this._hls.audioTracks.length > 1 || hasDefaultTextTrack) {\n      let numberOfEventsToWait = 0;\n      const handler = () => {\n        if (--numberOfEventsToWait == 0) {\n          this._maybeApplyAbrRestrictions();\n          this._resolveLoad({tracks: this._playerTracks});\n        }\n      };\n      if (hasDefaultTextTrack) {\n        numberOfEventsToWait++;\n        this._hls.once(Hlsjs.Events.SUBTITLE_FRAG_PROCESSED, handler);\n      }\n      if (this._hls.audioTracks.length > 1) {\n        numberOfEventsToWait++;\n        this._hls.once(Hlsjs.Events.AUDIO_TRACK_SWITCHING, handler);\n      }\n      this._resolveLoadTimeout = setTimeout(() => {\n        this._resolveLoad({tracks: this._playerTracks});\n      }, 1000);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * apply ABR restrictions\n   * @private\n   * @returns {void}\n   */\n  _maybeApplyAbrRestrictions(): void {\n    if (this._config.abr.enabled) {\n      if (this._config.abr.restrictions) {\n        const restrictions = this._config.abr.restrictions;\n        if (restrictions.maxBitrate) {\n          const minBitrate = restrictions.minBitrate ? restrictions.minBitrate : 0;\n          if (restrictions.maxBitrate > minBitrate) {\n            //Get the first level that is above our bitrate restriction\n            //If the corresponding level is not in the edges (level 0 or last level) then get the previous level index\n            //which has a bitrate value which is lower then the max bitrate restriction\n            let maxLevel = this._hls.levels.findIndex(level => level.bitrate > restrictions.maxBitrate);\n            if (maxLevel > 0) {\n              maxLevel = maxLevel - 1;\n            }\n            this._hls.autoLevelCapping = maxLevel;\n          } else {\n            HlsAdapter._logger.warn(\n              'Invalid maxBitrate restriction, maxBitrate must be greater than minBitrate',\n              minBitrate,\n              restrictions.maxBitrate\n            );\n          }\n        }\n      }\n    } else {\n      this._hls.currentLevel = 0;\n    }\n  }\n\n  /**\n   * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n   * @function _onLevelSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onLevelSwitched(event: string, data: any): void {\n    let videoTrack = this._playerTracks.find(track => {\n      return track instanceof VideoTrack && track.index === data.level;\n    });\n    HlsAdapter._logger.debug('Video track changed', videoTrack);\n    this._onTrackChanged(videoTrack);\n  }\n\n  /**\n   * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n   * @function _onAudioTrackSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onAudioTrackSwitched(event: string, data: any): void {\n    let audioTrack = this._playerTracks.find(track => {\n      return track instanceof AudioTrack && track.id === data.id;\n    });\n    HlsAdapter._logger.debug('Audio track changed', audioTrack);\n    this._onTrackChanged(audioTrack);\n    this._handleWaitingUponAudioTrackSwitch();\n  }\n\n  /**\n   * Trigger a playing event whenever an audio track is changed & time_update event is fired.\n   * This align Edge and IE behaviour to other browsers. When an audio track changed in IE & Edge, they trigger\n   * waiting event but not playing event.\n   * @returns {void}\n   * @private\n   */\n  _handleWaitingUponAudioTrackSwitch(): void {\n    const affectedBrowsers = ['IE', 'Edge'];\n    if (affectedBrowsers.includes(Env.browser.name)) {\n      const timeUpdateListener = () => {\n        this._trigger(EventType.PLAYING);\n        this._videoElement.removeEventListener(EventType.TIME_UPDATE, timeUpdateListener);\n      };\n      this._videoElement.addEventListener(EventType.TIME_UPDATE, timeUpdateListener);\n    }\n  }\n\n  /**\n   * Handles hls errors.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onError(data: any): void {\n    const errorType = data.type;\n    const errorDetails = data.details;\n    const errorFatal = data.fatal;\n    if (errorFatal) {\n      let error: typeof Error;\n      switch (errorType) {\n        case Hlsjs.ErrorTypes.NETWORK_ERROR:\n          if (\n            [Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR, Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT].includes(errorDetails) &&\n            !this._triedReloadWithRedirect &&\n            !this._config.forceRedirectExternalStreams\n          ) {\n            this._reloadWithDirectManifest();\n          } else {\n            error = new Error(Error.Severity.CRITICAL, Error.Category.NETWORK, Error.Code.HTTP_ERROR, errorDetails);\n          }\n          break;\n        case Hlsjs.ErrorTypes.MEDIA_ERROR:\n          if (this._handleMediaError()) {\n            error = new Error(Error.Severity.RECOVERABLE, Error.Category.MEDIA, Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n          } else {\n            error = new Error(Error.Severity.CRITICAL, Error.Category.MEDIA, Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n          }\n          break;\n        default:\n          error = new Error(Error.Severity.CRITICAL, Error.Category.PLAYER, Error.Code.HLS_FATAL_MEDIA_ERROR, errorDetails);\n          break;\n      }\n      this._trigger(EventType.ERROR, error);\n      if (error && error.severity === Error.Severity.CRITICAL) {\n        this.destroy();\n      }\n    } else {\n      const {category, code}: ErrorDetailsType = HlsJsErrorMap[errorDetails] || {category: 0, code: 0};\n      HlsAdapter._logger.warn(new Error(Error.Severity.RECOVERABLE, category, code, errorDetails));\n    }\n  }\n\n  /**\n   * Tries to handle media errors via hls.js error handlers\n   * @returns {boolean} - if media error is handled or not\n   * @private\n   */\n  _handleMediaError(): boolean {\n    const now: number = performance.now();\n    let recover = true;\n    if (this._checkTimeDeltaHasPassed(now, this._recoverDecodingErrorDate, this._config.recoverDecodingErrorDelay)) {\n      this._videoElement.addEventListener(EventType.LOADED_METADATA, this._onRecoveredCallback);\n      this._recoverDecodingError();\n    } else {\n      if (this._checkTimeDeltaHasPassed(now, this._recoverSwapAudioCodecDate, this._config.recoverSwapAudioCodecDelay)) {\n        this._videoElement.addEventListener(EventType.LOADED_METADATA, this._onRecoveredCallback);\n        this._recoverSwapAudioCodec();\n      } else {\n        recover = false;\n        HlsAdapter._logger.error('cannot recover, last media error recovery failed');\n      }\n    }\n    return recover;\n  }\n\n  /**\n   * trigger mediarecovered event if metadata is loaded (means the recovery succeeded)\n   * @returns {void}\n   * @private\n   */\n  _onRecovered(): void {\n    this._trigger(EventType.MEDIA_RECOVERED);\n    this._videoElement.removeEventListener(EventType.LOADED_METADATA, this._onRecoveredCallback);\n  }\n\n  /**\n   * Check if time ahs passed a certain delta\n   * @param {number} now - current time\n   * @param {number} then - previous time\n   * @param {number} delay - time delta in ms\n   * @returns {boolean} - if time delta has\n   * @private\n   */\n  _checkTimeDeltaHasPassed(now: number, then: number, delay: number): boolean {\n    return !then || now - then > delay;\n  }\n\n  /**\n   * handle recover from decoding error\n   * @returns {void}\n   * @private\n   */\n  _recoverDecodingError(): void {\n    this._recoverDecodingErrorDate = performance.now();\n    HlsAdapter._logger.warn('try to recover media Error');\n    this._hls.recoverMediaError();\n  }\n\n  /**\n   * handle recover from decoding error by swaping audio codec\n   * @returns {void}\n   * @private\n   */\n  _recoverSwapAudioCodec(): void {\n    this._recoverSwapAudioCodecDate = performance.now();\n    HlsAdapter._logger.warn('try to swap Audio Codec and recover media Error');\n    this._hls.swapAudioCodec();\n    this._hls.recoverMediaError();\n  }\n\n  /**\n   * Removes hls.js bindings.\n   * @returns {void}\n   * @private\n   */\n  _removeBindings(): void {\n    this._hls.off(Hlsjs.Events.ERROR, this._onError);\n    this._hls.off(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n    this._hls.off(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n    this._hls.off(Hlsjs.Events.MANIFEST_LOADED, this._onManifestLoaded);\n    this._hls.off(Hlsjs.Events.FPS_DROP, this._onFpsDrop);\n    this._videoElement.textTracks.onaddtrack = null;\n    this._videoElement.removeEventListener('addtrack', this._onAddTrack);\n    this._removeRecoveredCallbackListener();\n  }\n\n  /**\n   * Get the start time of DVR window in live playback in seconds.\n   * @returns {Number} - start time of DVR window.\n   * @public\n   */\n  getStartTimeOfDvrWindow(): number {\n    if (this.isLive()) {\n      try {\n        const nextLoadLevel = this._hls.levels[this._hls.nextLoadLevel],\n          details = nextLoadLevel.details,\n          fragments = details.fragments,\n          fragLength = fragments.length,\n          start = fragments[0].start + fragments[0].duration,\n          end = fragments[fragLength - 1].start + fragments[fragLength - 1].duration,\n          maxLatency =\n            this._hls.config.liveMaxLatencyDuration !== undefined\n              ? this._hls.config.liveMaxLatencyDuration\n              : this._hls.config.liveMaxLatencyDurationCount * details.targetduration,\n          minPosToSeek = Math.max(start - this._hls.config.maxFragLookUpTolerance, end - maxLatency);\n        return minPosToSeek;\n      } catch (e) {\n        HlsAdapter._logger.debug('Unable obtain the start of DVR window');\n        return 0;\n      }\n    } else {\n      return 0;\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./hls-adapter.js","module.exports = {\n\t\"recoverDecodingErrorDelay\": 3000,\n\t\"recoverSwapAudioCodecDelay\": 3000,\n\t\"abr\": {\n\t\t\"enabled\": true,\n\t\t\"restrictions\": {}\n\t},\n\t\"hlsConfig\": {\n\t\t\"fragLoadingMaxRetry\": 4,\n\t\t\"maxMaxBufferLength\": 60\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./default-config.json\n// module id = 4\n// module chunks = 0","// @flow\nimport Hlsjs from 'hls.js';\nimport {Error} from '@playkit-js/playkit-js';\n\ntype ErrorDetailsType = {category: number, code: number};\ntype HlsJsErrorMapType = {[name: string]: ErrorDetailsType};\n\nconst HlsJsErrorMap: HlsJsErrorMapType = {\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.MANIFEST_PARSING_ERROR]: {\n    category: Error.Category.MANIFEST,\n    code: Error.Code.HLSJS_CANNOT_PARSE\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.LEVEL_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.LEVEL_SWITCH_ERROR]: {\n    category: Error.Category.PLAYER,\n    code: Error.Code.BITRATE_SWITCH_ISSUE\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOOP_LOADING_ERROR]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.HTTP_ERROR\n  },\n  [Hlsjs.ErrorDetails.FRAG_LOAD_TIMEOUT]: {\n    category: Error.Category.NETWORK,\n    code: Error.Code.TIMEOUT\n  },\n  [Hlsjs.ErrorDetails.FRAG_PARSING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_FRAG_PARSING_ERROR\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPEND_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPEND_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_APPENDING_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_APPENDING_ISSUE\n  },\n  [Hlsjs.ErrorDetails.BUFFER_STALLED_ERROR]: {\n    category: Error.Category.MEDIA,\n    code: Error.Code.HLS_BUFFER_STALLED_ERROR\n  }\n};\n\nexport {HlsJsErrorMap};\nexport type {ErrorDetailsType};\n\n\n\n// WEBPACK FOOTER //\n// ./errors.js","//@flow\nimport {Utils} from '@playkit-js/playkit-js';\nimport Hlsjs from 'hls.js';\n\n/**\n * A plugin override for the loader function in hls.js.\n * It checks if it should use jsonp for the manifest first, else - the regular\n * loader is called.\n */\nexport default class pLoader extends Hlsjs.DefaultConfig.loader {\n  /**\n   * redirect external stream handler function\n   * @param {string} uri - the original uri\n   * @returns {string} uri - the redirected URI\n   * @static\n   */\n  static redirectExternalStreamsHandler: Function = uri => uri;\n\n  /**\n   * @constructor\n   * @param {Object} config - hlsjs config object. it also contains the jsonp callback function\n   */\n  constructor(config: Object) {\n    super(config);\n    const loadOrig = this.load.bind(this);\n    const callback = pLoader.redirectExternalStreamsHandler;\n    this.load = (context, config, callbacks) => {\n      const url = context.url;\n      if (context.type === 'manifest') {\n        Utils.Http.jsonp(url, callback, {\n          timeout: pLoader.redirectExternalStreamsTimeout\n        })\n          .then(uri => {\n            context.url = uri;\n            loadOrig(context, config, callbacks);\n          })\n          .catch(() => loadOrig(context, config, callbacks));\n      } else {\n        loadOrig(context, config, callbacks);\n      }\n    };\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./jsonp-ploader.js"],"sourceRoot":""}