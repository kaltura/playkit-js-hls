{"version":3,"sources":["webpack:///hls/webpack/universalModuleDefinition","webpack:///hls/playkit-hls.min.js","webpack:///hls/webpack/bootstrap 85c5dd4c3355289c155e","webpack:///hls/./hls-adapter.js","webpack:///hls/external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}","webpack:///hls/external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","_get","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_hls","_hls2","obj","default","_playkitJs","HlsAdapter","_BaseMediaSourceAdapt","videoElement","source","config","_logger","debug","version","_this","_config","_addBindings","hlsConfig","Utils","hasPropertyPath","playback","options","html5","hls","mimeType","canHlsPlayType","_hlsMimeTypes","includes","toLowerCase","toString","isHlsSupported","isSupported","on","Events","ERROR","_onError","bind","LEVEL_SWITCHED","_onLevelSwitched","AUDIO_TRACK_SWITCHED","_onAudioTrackSwitched","startTime","_this2","_loadPromise","Promise","resolve","MANIFEST_LOADED","event","data","_playerTracks","_parseTracks","tracks","startPosition","_sourceObj","url","loadSource","attachMedia","_videoElement","_removeBindings","detachMedia","destroy","audioTracks","_parseAudioTracks","videoTracks","_parseVideoTracks","levels","textTracks","_parseTextTracks","concat","hlsAudioTracks","settings","id","active","audioTrack","label","language","lang","index","push","AudioTrack","hlsVideoTracks","startLevel","bandwidth","bitrate","width","height","VideoTrack","vidTextTracks","mode","kind","TextTrack","videoTrack","autoLevelEnabled","currentLevel","textTrack","_disableAllTextTracks","_onTrackChanged","nextLevel","find","track","level","errorType","type","errorDetails","details","fatal","ErrorTypes","NETWORK_ERROR","error","startLoad","MEDIA_ERROR","recoverMediaError","ErrorDetails","MANIFEST_LOAD_ERROR","MANIFEST_LOAD_TIMEOUT","MANIFEST_PARSING_ERROR","LEVEL_LOAD_ERROR","LEVEL_LOAD_TIMEOUT","LEVEL_SWITCH_ERROR","FRAG_LOAD_ERROR","FRAG_LOOP_LOADING_ERROR","FRAG_LOAD_TIMEOUT","FRAG_PARSING_ERROR","BUFFER_APPEND_ERROR","BUFFER_APPENDING_ERROR","off","BaseMediaSourceAdapter","getLogger","registerMediaSourceAdapter"],"mappings":"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","file":"playkit-hls.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hls.js\"), require(\"playkit-js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hls.js\", \"playkit-js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsHls\"] = factory(require(\"hls.js\"), require(\"playkit-js\"));\n\telse\n\t\troot[\"PlaykitJsHls\"] = factory(root[\"Hls\"], root[\"Playkit\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"hls.js\"), require(\"playkit-js\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"hls.js\", \"playkit-js\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaykitJsHls\"] = factory(require(\"hls.js\"), require(\"playkit-js\"));\n\telse\n\t\troot[\"PlaykitJsHls\"] = factory(root[\"Hls\"], root[\"Playkit\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _hls = __webpack_require__(1);\n\nvar _hls2 = _interopRequireDefault(_hls);\n\nvar _playkitJs = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nvar HlsAdapter = function (_BaseMediaSourceAdapt) {\n  _inherits(HlsAdapter, _BaseMediaSourceAdapt);\n\n  _createClass(HlsAdapter, null, [{\n    key: 'createAdapter',\n\n\n    /**\n     * Factory method to create media source adapter.\n     * @function createAdapter\n     * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n     * @param {Object} source - The source Object.\n     * @param {Object} config - The player configuration.\n     * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n     * @static\n     */\n\n    /**\n     * The hls player instance.\n     * @member {any} _hls\n     * @private\n     */\n\n    /**\n     * The load promise\n     * @member {Promise<Object>} - _loadPromise\n     * @type {Promise<Object>}\n     * @private\n     */\n\n    /**\n     * Reference to the player tracks.\n     * @member {Array<Track>} - _playerTracks\n     * @type {Array<Track>}\n     * @private\n     */\n\n    /**\n     * The adapter logger.\n     * @member {any} _logger\n     * @static\n     * @private\n     */\n    value: function createAdapter(videoElement, source, config) {\n      var hlsConfig = {};\n      if (_playkitJs.Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n        hlsConfig = config.playback.options.html5.hls;\n      }\n      return new this(videoElement, source, hlsConfig);\n    }\n\n    /**\n     * Checks if hls adapter can play a given mime type.\n     * @function canPlayType\n     * @param {string} mimeType - The mime type to check.\n     * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n     * @static\n     */\n\n    /**\n     * The supported mime types by the hls adapter.\n     * @member {Array<string>} _hlsMimeType\n     * @static\n     * @private\n     */\n\n    /**\n     * The id of the adapter.\n     * @member {string} id\n     * @static\n     * @private\n     */\n\n  }, {\n    key: 'canPlayType',\n    value: function canPlayType(mimeType) {\n      var canHlsPlayType = typeof mimeType === 'string' ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n      HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n      return canHlsPlayType;\n    }\n\n    /**\n     * Checks if the hls adapter is supported.\n     * @function isSupported\n     * @returns {boolean} - Whether hls is supported.\n     * @static\n     */\n\n  }, {\n    key: 'isSupported',\n    value: function isSupported() {\n      var isHlsSupported = _hls2.default.isSupported();\n      HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n      return isHlsSupported;\n    }\n\n    /**\n     * @constructor\n     * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n     * @param {Object} source - The source object\n     * @param {Object} config - The media source adapter configuration\n     */\n\n  }]);\n\n  function HlsAdapter(videoElement, source, config) {\n    _classCallCheck(this, HlsAdapter);\n\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + _hls2.default.version);\n\n    var _this = _possibleConstructorReturn(this, (HlsAdapter.__proto__ || Object.getPrototypeOf(HlsAdapter)).call(this, videoElement, source, config));\n\n    _this._hls = new _hls2.default(_this._config);\n    _this._addBindings();\n    return _this;\n  }\n\n  /**\n   * Adds the required bindings with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n\n\n  _createClass(HlsAdapter, [{\n    key: '_addBindings',\n    value: function _addBindings() {\n      this._hls.on(_hls2.default.Events.ERROR, this._onError.bind(this));\n      this._hls.on(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n      this._hls.on(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n    }\n\n    /**\n     * Load the video source\n     * @function load\n     * @param {number} startTime - Optional time to start the video from.\n     * @returns {Promise<Object>} - The loaded data\n     * @override\n     */\n\n  }, {\n    key: 'load',\n    value: function load(startTime) {\n      var _this2 = this;\n\n      if (!this._loadPromise) {\n        this._loadPromise = new Promise(function (resolve) {\n          _this2._hls.on(_hls2.default.Events.MANIFEST_LOADED, function (event, data) {\n            HlsAdapter._logger.debug('The source has been loaded successfully');\n            _this2._playerTracks = _this2._parseTracks(data);\n            resolve({ tracks: _this2._playerTracks });\n          });\n          if (startTime) {\n            _this2._hls.startPosition = startTime;\n          }\n          if (_this2._sourceObj && _this2._sourceObj.url) {\n            _this2._hls.loadSource(_this2._sourceObj.url);\n            _this2._hls.attachMedia(_this2._videoElement);\n          }\n        });\n      }\n      return this._loadPromise;\n    }\n\n    /**\n     * Destroying the hls adapter.\n     * @function destroy\n     * @override\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      HlsAdapter._logger.debug('destroy');\n      _get(HlsAdapter.prototype.__proto__ || Object.getPrototypeOf(HlsAdapter.prototype), 'destroy', this).call(this);\n      this._loadPromise = null;\n      this._removeBindings();\n      this._hls.detachMedia();\n      this._hls.destroy();\n    }\n\n    /**\n     * Parse the hls tracks into player tracks.\n     * @param {any} data - The event data.\n     * @returns {Array<Track>} - The parsed tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTracks',\n    value: function _parseTracks(data) {\n      var audioTracks = this._parseAudioTracks(data.audioTracks || []);\n      var videoTracks = this._parseVideoTracks(data.levels || []);\n      var textTracks = this._parseTextTracks(this._videoElement.textTracks || []);\n      return audioTracks.concat(videoTracks).concat(textTracks);\n    }\n\n    /**\n     * Parse hls audio tracks into player audio tracks.\n     * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n     * @returns {Array<AudioTrack>} - The parsed audio tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseAudioTracks',\n    value: function _parseAudioTracks(hlsAudioTracks) {\n      var audioTracks = [];\n      for (var i = 0; i < hlsAudioTracks.length; i++) {\n        // Create audio tracks\n        var settings = {\n          id: hlsAudioTracks[i].id,\n          active: this._hls.audioTrack === hlsAudioTracks[i].id,\n          label: hlsAudioTracks[i].name,\n          language: hlsAudioTracks[i].lang,\n          index: i\n        };\n        audioTracks.push(new _playkitJs.AudioTrack(settings));\n      }\n      return audioTracks;\n    }\n\n    /**\n     * Parse hls video tracks into player video tracks.\n     * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n     * @returns {Array<VideoTrack>} - The parsed video tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseVideoTracks',\n    value: function _parseVideoTracks(hlsVideoTracks) {\n      var videoTracks = [];\n      for (var i = 0; i < hlsVideoTracks.length; i++) {\n        // Create video tracks\n        var settings = {\n          active: this._hls.startLevel === i,\n          label: hlsVideoTracks[i].name,\n          bandwidth: hlsVideoTracks[i].bitrate,\n          width: hlsVideoTracks[i].width,\n          height: hlsVideoTracks[i].height,\n          language: '',\n          index: i\n        };\n        videoTracks.push(new _playkitJs.VideoTrack(settings));\n      }\n      return videoTracks;\n    }\n\n    /**\n     * Parse native video tag text tracks into player text tracks.\n     * @param {TextTrackList} vidTextTracks - The native video tag text tracks.\n     * @returns {Array<TextTrack>} - The parsed text tracks.\n     * @private\n     */\n\n  }, {\n    key: '_parseTextTracks',\n    value: function _parseTextTracks(vidTextTracks) {\n      var textTracks = [];\n      for (var i = 0; i < vidTextTracks.length; i++) {\n        // Create text tracks\n        var settings = {\n          active: vidTextTracks[i].mode === 'showing',\n          label: vidTextTracks[i].label,\n          kind: vidTextTracks[i].kind,\n          language: vidTextTracks[i].language,\n          index: i\n        };\n        textTracks.push(new _playkitJs.TextTrack(settings));\n      }\n      return textTracks;\n    }\n\n    /**\n     * Select an audio track.\n     * @function selectAudioTrack\n     * @param {AudioTrack} audioTrack - the audio track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectAudioTrack',\n    value: function selectAudioTrack(audioTrack) {\n      if (audioTrack instanceof _playkitJs.AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n        this._hls.audioTrack = audioTrack.id;\n      }\n    }\n\n    /**\n     * Select a video track.\n     * @function selectVideoTrack\n     * @param {VideoTrack} videoTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectVideoTrack',\n    value: function selectVideoTrack(videoTrack) {\n      if (videoTrack instanceof _playkitJs.VideoTrack && (!videoTrack.active || this._hls.autoLevelEnabled) && this._hls.levels) {\n        this._hls.currentLevel = videoTrack.index;\n      }\n    }\n\n    /**\n     * Select a text track.\n     * @function selectTextTrack\n     * @param {TextTrack} textTrack - the track to select.\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'selectTextTrack',\n    value: function selectTextTrack(textTrack) {\n      if (textTrack instanceof _playkitJs.TextTrack && !textTrack.active && this._videoElement.textTracks) {\n        this._disableAllTextTracks();\n        this._videoElement.textTracks[textTrack.index].mode = 'showing';\n        HlsAdapter._logger.debug('Text track changed', textTrack);\n        this._onTrackChanged(textTrack);\n      }\n    }\n\n    /** Hide the text track\n     * @function hideTextTrack\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'hideTextTrack',\n    value: function hideTextTrack() {\n      this._disableAllTextTracks();\n    }\n\n    /**\n     * Enables adaptive bitrate switching according to hls.js logic.\n     * @function enableAdaptiveBitrate\n     * @returns {void}\n     * @public\n     */\n\n  }, {\n    key: 'enableAdaptiveBitrate',\n    value: function enableAdaptiveBitrate() {\n      this._hls.nextLevel = -1;\n    }\n\n    /**\n     * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n     * @function _onLevelSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onLevelSwitched',\n    value: function _onLevelSwitched(event, data) {\n      var videoTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.VideoTrack && track.index === data.level;\n      });\n      HlsAdapter._logger.debug('Video track changed', videoTrack);\n      this._onTrackChanged(videoTrack);\n    }\n\n    /**\n     * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n     * @function _onAudioTrackSwitched\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onAudioTrackSwitched',\n    value: function _onAudioTrackSwitched(event, data) {\n      var audioTrack = this._playerTracks.find(function (track) {\n        return track instanceof _playkitJs.AudioTrack && track.id === data.id;\n      });\n      HlsAdapter._logger.debug('Audio track changed', audioTrack);\n      this._onTrackChanged(audioTrack);\n    }\n\n    /**\n     * Disables all the video tag text tracks.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_disableAllTextTracks',\n    value: function _disableAllTextTracks() {\n      var vidTextTracks = this._videoElement.textTracks;\n      for (var i = 0; i < vidTextTracks.length; i++) {\n        vidTextTracks[i].mode = 'hidden';\n      }\n    }\n\n    /**\n     * Handles hls errors.\n     * @param {string} event - The event name.\n     * @param {any} data - The event data object.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(event, data) {\n      var errorType = data.type;\n      var errorDetails = data.details;\n      var errorFatal = data.fatal;\n      if (errorFatal) {\n        switch (errorType) {\n          case _hls2.default.ErrorTypes.NETWORK_ERROR:\n            HlsAdapter._logger.error(\"fatal network error encountered, try to recover\");\n            this._hls.startLoad();\n            break;\n          case _hls2.default.ErrorTypes.MEDIA_ERROR:\n            HlsAdapter._logger.error(\"fatal media error encountered, try to recover\");\n            this._hls.recoverMediaError();\n            break;\n          default:\n            HlsAdapter._logger.error(\"fatal error, cannot recover\");\n            this.destroy();\n            break;\n        }\n      } else {\n        switch (errorDetails) {\n          case _hls2.default.ErrorDetails.MANIFEST_LOAD_ERROR:\n          case _hls2.default.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n          case _hls2.default.ErrorDetails.MANIFEST_PARSING_ERROR:\n          case _hls2.default.ErrorDetails.LEVEL_LOAD_ERROR:\n          case _hls2.default.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n          case _hls2.default.ErrorDetails.LEVEL_SWITCH_ERROR:\n          case _hls2.default.ErrorDetails.FRAG_LOAD_ERROR:\n          case _hls2.default.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n          case _hls2.default.ErrorDetails.FRAG_LOAD_TIMEOUT:\n          case _hls2.default.ErrorDetails.FRAG_PARSING_ERROR:\n          case _hls2.default.ErrorDetails.BUFFER_APPEND_ERROR:\n          case _hls2.default.ErrorDetails.BUFFER_APPENDING_ERROR:\n            HlsAdapter._logger.error(errorType, errorDetails);\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    /**\n     * Removes hls.js bindings.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: '_removeBindings',\n    value: function _removeBindings() {\n      this._hls.off(_hls2.default.Events.ERROR, this._onError);\n      this._hls.off(_hls2.default.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n      this._hls.off(_hls2.default.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n    }\n\n    /**\n     * Getter for the src that the adapter plays on the video element.\n     * In case the adapter preformed a load it will return the manifest url.\n     * @public\n     * @returns {string} - The src url.\n     */\n\n  }, {\n    key: 'src',\n    get: function get() {\n      if (this._loadPromise && this._sourceObj) {\n        return this._sourceObj.url;\n      }\n      return \"\";\n    }\n  }]);\n\n  return HlsAdapter;\n}(_playkitJs.BaseMediaSourceAdapter);\n\n// Register hls adapter to the media source adapter provider.\n\n\nHlsAdapter.id = 'HlsAdapter';\nHlsAdapter._logger = _playkitJs.BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\nHlsAdapter._hlsMimeTypes = ['application/x-mpegurl', 'application/vnd.apple.mpegurl', 'audio/mpegurl', 'audio/x-mpegurl', 'video/x-mpegurl', 'video/mpegurl', 'application/mpegurl'];\nexports.default = HlsAdapter;\nif (HlsAdapter.isSupported()) {\n  (0, _playkitJs.registerMediaSourceAdapter)(HlsAdapter);\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// playkit-hls.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 85c5dd4c3355289c155e","//@flow\nimport Hlsjs from 'hls.js'\nimport {registerMediaSourceAdapter, BaseMediaSourceAdapter} from 'playkit-js'\nimport {Track, VideoTrack, AudioTrack, TextTrack} from 'playkit-js'\nimport {Utils} from 'playkit-js'\n\n/**\n * Adapter of hls.js lib for hls content.\n * @classdesc\n */\nexport default class HlsAdapter extends BaseMediaSourceAdapter {\n  /**\n   * The id of the adapter.\n   * @member {string} id\n   * @static\n   * @private\n   */\n  static id: string = 'HlsAdapter';\n  /**\n   * The adapter logger.\n   * @member {any} _logger\n   * @static\n   * @private\n   */\n  static _logger = BaseMediaSourceAdapter.getLogger(HlsAdapter.id);\n  /**\n   * The supported mime types by the hls adapter.\n   * @member {Array<string>} _hlsMimeType\n   * @static\n   * @private\n   */\n  static _hlsMimeTypes: Array<string> = [\n    'application/x-mpegurl',\n    'application/vnd.apple.mpegurl',\n    'audio/mpegurl',\n    'audio/x-mpegurl',\n    'video/x-mpegurl',\n    'video/mpegurl',\n    'application/mpegurl'\n  ];\n  /**\n   * The hls player instance.\n   * @member {any} _hls\n   * @private\n   */\n  _hls: any;\n  /**\n   * The load promise\n   * @member {Promise<Object>} - _loadPromise\n   * @type {Promise<Object>}\n   * @private\n   */\n  _loadPromise: ?Promise<Object>;\n  /**\n   * Reference to the player tracks.\n   * @member {Array<Track>} - _playerTracks\n   * @type {Array<Track>}\n   * @private\n   */\n  _playerTracks: Array<Track>;\n\n  /**\n   * Factory method to create media source adapter.\n   * @function createAdapter\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\n   * @param {Object} source - The source Object.\n   * @param {Object} config - The player configuration.\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\n   * @static\n   */\n  static createAdapter(videoElement: HTMLVideoElement, source: Source, config: Object): IMediaSourceAdapter {\n    let hlsConfig = {};\n    if (Utils.Object.hasPropertyPath(config, 'playback.options.html5.hls')) {\n      hlsConfig = config.playback.options.html5.hls;\n    }\n    return new this(videoElement, source, hlsConfig);\n  }\n\n  /**\n   * Checks if hls adapter can play a given mime type.\n   * @function canPlayType\n   * @param {string} mimeType - The mime type to check.\n   * @returns {boolean} - Whether the hls adapter can play a specific mime type.\n   * @static\n   */\n  static canPlayType(mimeType: string): boolean {\n    let canHlsPlayType = (typeof mimeType === 'string') ? HlsAdapter._hlsMimeTypes.includes(mimeType.toLowerCase()) : false;\n    HlsAdapter._logger.debug('canPlayType result for mimeType:' + mimeType + ' is ' + canHlsPlayType.toString());\n    return canHlsPlayType;\n  }\n\n  /**\n   * Checks if the hls adapter is supported.\n   * @function isSupported\n   * @returns {boolean} - Whether hls is supported.\n   * @static\n   */\n  static isSupported(): boolean {\n    let isHlsSupported = Hlsjs.isSupported();\n    HlsAdapter._logger.debug('isSupported:' + isHlsSupported);\n    return isHlsSupported;\n  }\n\n  /**\n   * @constructor\n   * @param {HTMLVideoElement} videoElement - The video element which will bind to the hls adapter\n   * @param {Object} source - The source object\n   * @param {Object} config - The media source adapter configuration\n   */\n  constructor(videoElement: HTMLVideoElement, source: Source, config: Object) {\n    HlsAdapter._logger.debug('Creating adapter. Hls version: ' + Hlsjs.version);\n    super(videoElement, source, config);\n    this._hls = new Hlsjs(this._config);\n    this._addBindings();\n  }\n\n  /**\n   * Adds the required bindings with hls.js.\n   * @function _addBindings\n   * @private\n   * @returns {void}\n   */\n  _addBindings(): void {\n    this._hls.on(Hlsjs.Events.ERROR, this._onError.bind(this));\n    this._hls.on(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched.bind(this));\n    this._hls.on(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched.bind(this));\n  }\n\n  /**\n   * Load the video source\n   * @function load\n   * @param {number} startTime - Optional time to start the video from.\n   * @returns {Promise<Object>} - The loaded data\n   * @override\n   */\n  load(startTime: ?number): Promise<Object> {\n    if (!this._loadPromise) {\n      this._loadPromise = new Promise((resolve) => {\n        this._hls.on(Hlsjs.Events.MANIFEST_LOADED, (event: string, data: any) => {\n          HlsAdapter._logger.debug('The source has been loaded successfully');\n          this._playerTracks = this._parseTracks(data);\n          resolve({tracks: this._playerTracks});\n        });\n        if (startTime) {\n          this._hls.startPosition = startTime;\n        }\n        if (this._sourceObj && this._sourceObj.url) {\n          this._hls.loadSource(this._sourceObj.url);\n          this._hls.attachMedia(this._videoElement);\n        }\n      });\n    }\n    return this._loadPromise;\n  }\n\n  /**\n   * Destroying the hls adapter.\n   * @function destroy\n   * @override\n   */\n  destroy(): void {\n    HlsAdapter._logger.debug('destroy');\n    super.destroy();\n    this._loadPromise = null;\n    this._removeBindings();\n    this._hls.detachMedia();\n    this._hls.destroy();\n  }\n\n  /**\n   * Parse the hls tracks into player tracks.\n   * @param {any} data - The event data.\n   * @returns {Array<Track>} - The parsed tracks.\n   * @private\n   */\n  _parseTracks(data: any): Array<Track> {\n    let audioTracks = this._parseAudioTracks(data.audioTracks || []);\n    let videoTracks = this._parseVideoTracks(data.levels || []);\n    let textTracks = this._parseTextTracks(this._videoElement.textTracks || []);\n    return audioTracks.concat(videoTracks).concat(textTracks);\n  }\n\n  /**\n   * Parse hls audio tracks into player audio tracks.\n   * @param {Array<Object>} hlsAudioTracks - The hls audio tracks.\n   * @returns {Array<AudioTrack>} - The parsed audio tracks.\n   * @private\n   */\n  _parseAudioTracks(hlsAudioTracks: Array<Object>): Array<AudioTrack> {\n    let audioTracks = [];\n    for (let i = 0; i < hlsAudioTracks.length; i++) {\n      // Create audio tracks\n      let settings = {\n        id: hlsAudioTracks[i].id,\n        active: this._hls.audioTrack === hlsAudioTracks[i].id,\n        label: hlsAudioTracks[i].name,\n        language: hlsAudioTracks[i].lang,\n        index: i\n      };\n      audioTracks.push(new AudioTrack(settings));\n    }\n    return audioTracks;\n  }\n\n  /**\n   * Parse hls video tracks into player video tracks.\n   * @param {Array<Object>} hlsVideoTracks - The hls video tracks.\n   * @returns {Array<VideoTrack>} - The parsed video tracks.\n   * @private\n   */\n  _parseVideoTracks(hlsVideoTracks: Array<Object>): Array<VideoTrack> {\n    let videoTracks = [];\n    for (let i = 0; i < hlsVideoTracks.length; i++) {\n      // Create video tracks\n      let settings = {\n        active: this._hls.startLevel === i,\n        label: hlsVideoTracks[i].name,\n        bandwidth: hlsVideoTracks[i].bitrate,\n        width: hlsVideoTracks[i].width,\n        height: hlsVideoTracks[i].height,\n        language: '',\n        index: i\n      };\n      videoTracks.push(new VideoTrack(settings));\n    }\n    return videoTracks;\n  }\n\n  /**\n   * Parse native video tag text tracks into player text tracks.\n   * @param {TextTrackList} vidTextTracks - The native video tag text tracks.\n   * @returns {Array<TextTrack>} - The parsed text tracks.\n   * @private\n   */\n  _parseTextTracks(vidTextTracks: TextTrackList | Array<Object>): Array<TextTrack> {\n    let textTracks = [];\n    for (let i = 0; i < vidTextTracks.length; i++) {\n      // Create text tracks\n      let settings = {\n        active: vidTextTracks[i].mode === 'showing',\n        label: vidTextTracks[i].label,\n        kind: vidTextTracks[i].kind,\n        language: vidTextTracks[i].language,\n        index: i\n      };\n      textTracks.push(new TextTrack(settings));\n    }\n    return textTracks;\n  }\n\n  /**\n   * Select an audio track.\n   * @function selectAudioTrack\n   * @param {AudioTrack} audioTrack - the audio track to select.\n   * @returns {void}\n   * @public\n   */\n  selectAudioTrack(audioTrack: AudioTrack): void {\n    if (audioTrack instanceof AudioTrack && !audioTrack.active && this._hls.audioTracks) {\n      this._hls.audioTrack = audioTrack.id;\n    }\n  }\n\n  /**\n   * Select a video track.\n   * @function selectVideoTrack\n   * @param {VideoTrack} videoTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectVideoTrack(videoTrack: VideoTrack): void {\n    if (videoTrack instanceof VideoTrack && (!videoTrack.active || this._hls.autoLevelEnabled) && this._hls.levels) {\n      this._hls.currentLevel = videoTrack.index;\n    }\n  }\n\n  /**\n   * Select a text track.\n   * @function selectTextTrack\n   * @param {TextTrack} textTrack - the track to select.\n   * @returns {void}\n   * @public\n   */\n  selectTextTrack(textTrack: TextTrack): void {\n    if (textTrack instanceof TextTrack && !textTrack.active && this._videoElement.textTracks) {\n      this._disableAllTextTracks();\n      this._videoElement.textTracks[textTrack.index].mode = 'showing';\n      HlsAdapter._logger.debug('Text track changed', textTrack);\n      this._onTrackChanged(textTrack);\n    }\n  }\n\n  /** Hide the text track\n   * @function hideTextTrack\n   * @returns {void}\n   * @public\n   */\n  hideTextTrack(): void {\n    this._disableAllTextTracks();\n  }\n\n  /**\n   * Enables adaptive bitrate switching according to hls.js logic.\n   * @function enableAdaptiveBitrate\n   * @returns {void}\n   * @public\n   */\n  enableAdaptiveBitrate(): void {\n    this._hls.nextLevel = -1;\n  }\n\n  /**\n   * Triggers on video track selection (auto or manually) the 'videotrackchanged' event forward.\n   * @function _onLevelSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onLevelSwitched(event: string, data: any): void {\n    let videoTrack = this._playerTracks.find((track) => {\n      return (track instanceof VideoTrack && track.index === data.level);\n    });\n    HlsAdapter._logger.debug('Video track changed', videoTrack);\n    this._onTrackChanged(videoTrack);\n  }\n\n  /**\n   * Triggers on audio track selection (auto or manually) the 'audiotrackchanged' event forward.\n   * @function _onAudioTrackSwitched\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onAudioTrackSwitched(event: string, data: any): void {\n    let audioTrack = this._playerTracks.find((track) => {\n      return (track instanceof AudioTrack && track.id === data.id);\n    });\n    HlsAdapter._logger.debug('Audio track changed', audioTrack);\n    this._onTrackChanged(audioTrack);\n  }\n\n  /**\n   * Disables all the video tag text tracks.\n   * @returns {void}\n   * @private\n   */\n  _disableAllTextTracks() {\n    let vidTextTracks = this._videoElement.textTracks;\n    for (let i = 0; i < vidTextTracks.length; i++) {\n      vidTextTracks[i].mode = 'hidden';\n    }\n  }\n\n  /**\n   * Handles hls errors.\n   * @param {string} event - The event name.\n   * @param {any} data - The event data object.\n   * @private\n   * @returns {void}\n   */\n  _onError(event: string, data: any): void {\n    let errorType = data.type;\n    let errorDetails = data.details;\n    let errorFatal = data.fatal;\n    if (errorFatal) {\n      switch (errorType) {\n        case Hlsjs.ErrorTypes.NETWORK_ERROR:\n          HlsAdapter._logger.error(\"fatal network error encountered, try to recover\");\n          this._hls.startLoad();\n          break;\n        case Hlsjs.ErrorTypes.MEDIA_ERROR:\n          HlsAdapter._logger.error(\"fatal media error encountered, try to recover\");\n          this._hls.recoverMediaError();\n          break;\n        default:\n          HlsAdapter._logger.error(\"fatal error, cannot recover\");\n          this.destroy();\n          break;\n      }\n    } else {\n      switch (errorDetails) {\n        case Hlsjs.ErrorDetails.MANIFEST_LOAD_ERROR:\n        case Hlsjs.ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n        case Hlsjs.ErrorDetails.MANIFEST_PARSING_ERROR:\n        case Hlsjs.ErrorDetails.LEVEL_LOAD_ERROR:\n        case Hlsjs.ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case Hlsjs.ErrorDetails.LEVEL_SWITCH_ERROR:\n        case Hlsjs.ErrorDetails.FRAG_LOAD_ERROR:\n        case Hlsjs.ErrorDetails.FRAG_LOOP_LOADING_ERROR:\n        case Hlsjs.ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case Hlsjs.ErrorDetails.FRAG_PARSING_ERROR:\n        case Hlsjs.ErrorDetails.BUFFER_APPEND_ERROR:\n        case Hlsjs.ErrorDetails.BUFFER_APPENDING_ERROR:\n          HlsAdapter._logger.error(errorType, errorDetails);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  /**\n   * Removes hls.js bindings.\n   * @returns {void}\n   * @private\n   */\n  _removeBindings(): void {\n    this._hls.off(Hlsjs.Events.ERROR, this._onError);\n    this._hls.off(Hlsjs.Events.LEVEL_SWITCHED, this._onLevelSwitched);\n    this._hls.off(Hlsjs.Events.AUDIO_TRACK_SWITCHED, this._onAudioTrackSwitched);\n  }\n\n  /**\n   * Getter for the src that the adapter plays on the video element.\n   * In case the adapter preformed a load it will return the manifest url.\n   * @public\n   * @returns {string} - The src url.\n   */\n  get src(): string {\n    if (this._loadPromise && this._sourceObj) {\n      return this._sourceObj.url;\n    }\n    return \"\";\n  }\n}\n\n// Register hls adapter to the media source adapter provider.\nif (HlsAdapter.isSupported()) {\n  registerMediaSourceAdapter(HlsAdapter);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./hls-adapter.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"hls.js\",\"commonjs2\":\"hls.js\",\"amd\":\"hls.js\",\"root\":\"Hls\"}\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"playkit-js\",\"commonjs2\":\"playkit-js\",\"amd\":\"playkit-js\",\"root\":\"Playkit\"}\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}